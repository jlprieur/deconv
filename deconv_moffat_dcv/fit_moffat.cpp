/****************************************************************** 
* fit_moffat 
* Program that fits a Moffat's profile 
*
* rr^2 = (x - xc)^2 + ee * (x - xc) (y - yc) + (1 + ff) * (y -yc)^2
* f(x,y) = hh / [ 1. + (rr * bb)^2 ]^qq 
*
* JLP
* Version 08/01/2007
* Version 02/02/2011
*******************************************************************/ 
#include "jlp_ftoc.h"
#define JLP_USE_X11
#include "../splot/lib/jlp_dialog.h"
#include "../splot/lib/jlp_gdlg.h"
#include "../splot/lib/jlp_gdlg_x11.h"

#define NN 60

#define DEBUG
/*
#define CHECK_GRAD 
#define DEBUGG
*/
#define NSTARS_MAX 3

/*
* i_min, i_max, j_min, j_max: coordinates (in pixels) of the area to be used
*                             in the input image
*/
static int nstars, nparams, imin, imax, jmin, jmax, idim, npts;
static int circular_isoph, qq_is_fixed, constant_background;
static float *image;
static double qq_value;

/******************* Prototypes: ****************************/

/* Declaring linkage specification to have "correct names"
* that can be linked with C programs */

#ifdef __cplusplus
extern "C" {
#endif

/* In "$HOME/src_math/lbfgs_bcm/dcv_lbfgs.c" */
int JLP_LBFGS(int *n, double *x, double *lbound, double *ubound,
              int *nbound, double *f, double *ftol, double *pgtol,
              int *niter_max, double (*func)(double *),
              void (*dfunc)(double *, double *));

#ifdef __cplusplus
}
#endif


/* Defined here: */
static int input_from_dialog_box(char *filename, int *n_stars, double *xc, 
                             double *yc, double *qq, int *qq_fixed, 
                             int *circ_isoph, int *constant_bck,
                             double *fwhm, double *factr, 
                             double *pgtol, int *niter_max, int *is_OK);
static int input_from_file(char *param_file, char *filename, int *n_stars, 
                           double *xc, double *yc, double *qq, int *qq_fixed, 
                           int *circ_isoph, int *constant_bck, double *fwhm, 
                           double *factr, double *pgtol, int *niter_max, 
                           int *is_OK);
static int default_initialization(double *xx, int nx, int ny, double *fwhm);
static double profile_value(double s0, double s1, double s2, double s3,
                            double *xc, double *yc, double *hh, double bb2, 
                            double qq, double ee, double ff, double x, 
                            double y);
static int fit_moffat_profile(double *xx, double *xc, double *yc, 
                              int circ_isoph, int qq_fixed, int constant_bck, 
                              double factr, double pgtol, int niter_max,
                              FILE *fp_log);
static double moffat_func(double *xx);
static void moffat_dfunc(double *xx, double *dx);
static int param_from_xx(double *xx, double *s0, double *s1, double *s2,
                         double *s3, double *xc, double *yc, double *hh, 
                         double *ee, double *ff, double *bb, double *qq, 
                         int nstars);
static int check_grad(double *x1, int nparams, double (*func)(double []), 
                      void (*dfunc)(double[], double[]));
static int set_limits(double *xc, double *yc, int *imin, int *imax, int *jmin, 
                      int *jmax, int nstars, int nx, int ny, double fwhm);
static int compute_residuals(float *image, int nx, int ny, int idim,
                             char *input_filename,
                             double s0, double s1, double s2, double s3, 
                             double bb, double qq, double ee, double ff, 
                             double *xc, double *yc, double *hh);

int main(int argc, char *argv[])
{
int status, interactive, is_OK, circ_isoph, qq_fixed, niter_max; 
int constant_bck;
INT_PNTR pntr;
INT4 nx, ny;
double rho, theta, Dm;
double *xx, factr, pgtol; 
double xc[NSTARS_MAX], yc[NSTARS_MAX], hh[NSTARS_MAX]; 
double fwhm, bb, qq, ee, ff, s0, s1, s2, s3; 
register int i, j, k, m;
char filename[60], comments[80], param_file[60];
FILE *fp_log;

printf(" Program to fit Moffat's profiles\n");
printf(" JLP version 01/02/2011\n");

/* Reduce the number of arguments when "runs" is used and  argc=7 */
if(argc == 7)
 {
 for(i = 6; i > 0; i--)
  {
   if(*argv[i] == ' ' || *argv[i] == '\0')argc--;
   else break;
  }
 }

/* Default values: */
interactive = 1;
circ_isoph = 1;
nstars = 2;
qq = 1.5;

/*     factr is a DOUBLE PRECISION variable that must be set by the user.
c       It is a tolerance in the termination test for the algorithm.
c       The iteration will stop when
c
c        (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
c
c       where epsmch is the machine precision which is automatically
c       generated by the code. Typical values for factr on a computer
c       with 15 digits of accuracy in double precision are:
c       factr=1.e+12 for low accuracy;
c             1.e+7  for moderate accuracy;
c             1.e+1  for extremely high accuracy.
c       The user can suppress this termination test by setting factr=0.
c
c     pgtol is a double precision variable.
c       On entry pgtol >= 0 is specified by the user.  The iteration
c         will stop when
c
c                 max{|proj dx_i | i = 1, ..., n} <= pgtol
c
c         where proj dx_i is the ith component of the projected gradient.
c       The user can suppress this termination test by setting pgtol=0.
*/
factr = 1.e+1;
pgtol = 1.e-9;
niter_max = 2000;
filename[0] = '\0';
qq_is_fixed = 0;
constant_bck = 1;
for(i = 0; i < NSTARS_MAX; i++) {
  xc[i] = 0.;
  xc[i] = 0.;
  hh[i] = 0.;
  }

if(argc > 1) {
sscanf(argv[1],"%s", filename);
if(argc > 2) {
  sscanf(argv[2],"%s", param_file);
  interactive = 0;
  }
} else {
printf(" Usage: fit_moffat input_file [param_file] \n");
exit(-1);
}

/* Open logbook: */
if((fp_log = fopen("fit_moffat.log", "w")) == NULL) {
 fprintf(stderr, "Fatal error opening output logfile\n");
 exit(-1);
}

fprintf(fp_log, " Program to fit Moffat's profiles\n");
fprintf(fp_log, " JLP version 01/02/2011\n");

/* Display popup window with default values: */
if(interactive) {
  input_from_dialog_box(filename, &nstars, xc, yc, &qq, &qq_fixed,
                        &circ_isoph, &constant_bck, &fwhm, &factr, &pgtol, 
                        &niter_max, &is_OK);
  if(!is_OK) exit(-1);
} else {
  input_from_file(param_file, filename, &nstars, xc, yc, &qq, &qq_fixed,
                  &circ_isoph, &constant_bck, &fwhm, &factr, &pgtol, 
                  &niter_max, &is_OK);
}

/* Save qq value to static variable: */
qq_value = qq;

printf("Initial values: \n"); 
fprintf(fp_log, "Initial values: \n"); 
printf("Filename=%s \n nstars=%d qq=%.3f qq_fixed=%d\n", 
        filename, nstars, qq, qq_fixed);
fprintf(fp_log, "Filename=%s \n nstars=%d qq=%.3f qq_fixed=%d\n", 
        filename, nstars, qq, qq_fixed);
printf("circ_isoph=%d constant_bck=%d fwhm=%f\n", 
         circ_isoph, constant_bck, fwhm);
fprintf(fp_log, "circ_isoph=%d constant_bck=%d fwhm=%f\n", 
         circ_isoph, constant_bck, fwhm);
printf("xc,yc(1)= %.3f,%.3f  xc,yc(2)= %.3f,%.3f xc,yc(3)= %.3f,%.3f\n",
        xc[0], yc[0], xc[1], yc[1], xc[2], yc[2]);
fprintf(fp_log, "xc,yc(1)= %.3f,%.3f  xc,yc(2)= %.3f,%.3f xc,yc(3)= %.3f,%.3f\n",
        xc[0], yc[0], xc[1], yc[1], xc[2], yc[2]);
printf("factr=%.3e pgtol=%.3e niter_max=%d\n", 
        factr, pgtol, niter_max);
fprintf(fp_log, "factr=%.3e pgtol=%.3e niter_max=%d\n", 
        factr, pgtol, niter_max);

if(nstars < 1 || nstars > NSTARS_MAX) {
 fprintf(stderr, "fit_moffat/Fatal error invalid value for nstars (=%d !) \n",
         nstars);
 fprintf(fp_log, "fit_moffat/Fatal error invalid value for nstars (=%d !) \n",
         nstars);
 fclose(fp_log);
 exit(-1);
 }

/* xx array with the parameters (from 0 to 3*nstars + 7):
* For one star:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = bb, xx[8] = qq, xx[9] = ee, xx[10] = ff
* For two stars:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = xc[0], xx[8] = yc[0], xx[9] = hh[0],
* xx[10] = bb, xx[11] = qq, xx[12] = ee, xx[13] = ff
* nparams = 3*nstars + 5 if circular isophotes and qq fixed
* nparams = 3*nstars + 6 if circular isophotes and qq free
* nparams = 3*nstars + 8 if elliptical isophotes and qq free
*/

/* s0, bb, and (xc, yc, hh)*nstars */
 nparams = 3*nstars + 2;
 if(!constant_bck) nparams += 2;
/* NB: qq value is saved to qq_value static variable: */
 if(!qq_fixed) nparams++;
 if(!circ_isoph) nparams += 2;
printf("OK: will fit %d parameters\n", nparams);

/* Allocate enough memory to fit ee and ff even when circular isophotes */
if((xx = (double *)malloc((3*nstars + 8) * sizeof(double))) == NULL) {
  fprintf(stderr, "fit_moffat/Fatal error allocating memory space for xx\n");
  fprintf(fp_log, "fit_moffat/Fatal error allocating memory space for xx\n");
  fclose(fp_log);
  exit(-1);
 }

JLP_INQUIFMT();

/* Read input image 
*/
status = JLP_VM_READIMAG1(&pntr, &nx, &ny, filename, comments);
if(status) exit(-1);

image = (float *) pntr;
idim = nx;

/* Sky value estimated at the corners of the image: */
k = 0;
/* s0 */
xx[k++] = (image[0] + image[nx - 1] + image[nx - 1 + (ny - 1)*idim]
        + image[(ny -1)*idim])/4.;

printf("INIT/xx[%d]=%.3f (sky background)\n", k-1, xx[k-1]);
fprintf(fp_log, "INIT/xx[%d]=%.3f (sky background)\n", k-1, xx[k-1]);

/* s1, s2, s3 */
if(!constant_bck) {
 xx[k++] = 0.;
 xx[k++] = 0.;
 xx[k++] = 0.;
 }

/* Central brightness hh is taken equal to the image value 
* at the location (xc, yc): 
*/
for(m = 0; m < nstars; m++) {
  hh[m] = image[NINT(xc[m]) + NINT(yc[m]) * idim] - xx[0]; 
  }

  for(m = 0; m < nstars; m++) {
    xx[k++] = xc[m]; 
    xx[k++] = yc[m]; 
    xx[k++] = hh[m];
    printf("INIT/xc=xx[%d]=%.3f,yc=xx[%d]=%.3f hh=xx[%d]=%.3e\n", 
           k-3, xx[k-3], k-2, xx[k-2], k-1, xx[k-1]);
    }
  bb = 2. * sqrt(pow(2., (1./qq)) - 1.) / fwhm;
  xx[k++] = bb; 
  printf(" INIT/fwhm=%f xx[%d]=%f=bb=%f qq=%.1f=%.1f\n", fwhm, k-1, 
         xx[k-1], bb, qq, qq_value);
/* NB: qq value is saved to qq_value static variable: */
  if(!qq_fixed) {
    xx[k++] = qq; 
    printf(" INIT/xx[%d]=%f=qq=%f\n", k-1, xx[k-1], qq); 
    }
/* ee and ff */
  if(!circ_isoph) {
#ifdef CHECK_GRAD
    xx[k++] = 0.1; 
    xx[k++] = 0.1;
#else
    xx[k++] = 0.; 
    xx[k++] = 0.;
#endif
  }
/*
  default_initialization(xx, nx, ny, &fwhm);
*/

#ifdef DEBUG
printf("k=%d nparams=%d\n", k, nparams);
for(i = 0; i < nparams; i++) 
   printf("Initialisation/xx[%d] = %f\n", i, xx[i]);
#endif


 set_limits(xc, yc, &imin, &imax, &jmin, &jmax, nstars, nx, ny, fwhm);
 npts = 0; 
 for(j = jmin; j < jmax; j++)
   for(i = imin; i < imax; i++) npts++;

/* Possibility of checking that the gradient is OK: */
#ifdef CHECK_GRAD 
/* Saving to static variables (that will be used by moffat_func 
* and moffat_dfunc: */
  circular_isoph = circ_isoph;
  qq_is_fixed = qq_fixed;
  constant_background = constant_bck;

  status = check_grad(xx, nparams, moffat_func, moffat_dfunc);
  if(status != 12345) return(0);
#endif

status = fit_moffat_profile(xx, xc, yc, circ_isoph, qq_fixed, constant_bck,
                            factr, pgtol, niter_max, fp_log);

printf(" Solution with factr=%e and pgtol=%e is: (with npts=%d)\n", 
         factr, pgtol, npts);
fprintf(fp_log, " Solution with factr=%e and pgtol=%e is: (with npts=%d)\n", 
         factr, pgtol, npts);

/* Compute values of parameters from solution vector xx: */
param_from_xx(xx, &s0, &s1, &s2, &s3, xc, yc, hh, &ee, &ff, &bb, &qq, nstars);

for(m = 0; m < nstars; m++) { 
   printf(" Star#%d xc=%f yc=%f hh=%f\n", m, xc[m], yc[m], hh[m]);
   fprintf(fp_log, " Star#%d xc=%f yc=%f hh=%f\n", m, xc[m], yc[m], hh[m]);
   }

for(m = 1; m < nstars; m++) { 
   rho = sqrt(SQUARE(xc[m] - xc[0]) + SQUARE(yc[m] - yc[0]));
   theta = atan2(yc[m] - yc[0], xc[m] - xc[0]) * 180. / 3.14159;
   Dm = -2.5 * log10(hh[m] / hh[0]);
   printf(" Star#%d - Star#0 rho=%f theta=%f Dmag=%f\n", m, rho, theta, Dm);
   fprintf(fp_log, " Star#%d - Star#0 rho=%f theta=%f Dmag=%f\n", m, rho, theta, Dm);
   }


fwhm = 2. * sqrt(pow(2., 1./qq) - 1.) / bb;
printf(" s0=%f s1=%f s2=%f s3=%f\n", s0, s1, s2, s3); 
fprintf(fp_log, " s0=%f s1=%f s2=%f s3=%f\n", s0, s1, s2, s3); 
printf(" bb=%f qq=%f ee=%f ff=%f (fwhm=%f)\n", bb, qq, ee, ff, fwhm); 
fprintf(fp_log, " bb=%f qq=%f ee=%f ff=%f (fwhm=%f)\n", bb, qq, ee, ff, fwhm); 

compute_residuals(image, nx, ny, nx, filename, s0, s1, s2, s3, bb, qq, 
                  ee, ff, xc, yc, hh);

 free(xx);
 fclose(fp_log);
return(0);
}
/***********************************************************************
* rr^2 = (x - xc)^2 + ee * (x - xc) (y - yc) + (1 + ff) * (y -yc)^2
* f(x,y) = hh / [ 1. + (rr * bb)^2 ]^qq 
*
* INPUT:
* image: array to be fitted
* nx, ny: size of image
* nstars: number of stars to be fitted
*
* OUTPUT
* xx: parameters found for the Moffat profiles
************************************************************************/
static int default_initialization(double *xx, int nx, int ny, double *fwhm)
{
float bb, qq;
register int k, m;

/* First guess: 
* xx array with the parameters (from 0 to 3*nstars + 7):
* For one star:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = bb, xx[8] = qq, xx[9] = ee, xx[10] = ff
*/
/* s0, s1, s2 are initialized outside of this routine */

k = 3;
for(m = 0; m < nstars; m++) {
/* xc[m] */
 xx[k++] = nx/2; 
/* yc[m] */
 xx[k++] = ny/2; 
/* hh[m] */
 xx[k++] = 10.; 
}

 *fwhm = 5.;
 qq = 1.5;
/* fwhm =  sqrt( 2^{1/qq} - 1 ) / bb
*/
 bb = 2. * sqrt(pow(2., (1./qq)) - 1.) / *fwhm;

/* bb (linked to seeing FWHM width) */
 xx[k++] = bb;
/* qq exponent */
 if(!qq_is_fixed) xx[k++] = qq;

/* ee (for ellipses) */
#ifdef CHECK_GRAD 
 xx[k++] = 0.1;
#else
 xx[k++] = 0.;
#endif
/* ff (for ellipses) */
#ifdef CHECK_GRAD 
 xx[k++] = 0.1;
#else
 xx[k++] = 0.;
#endif

return(0);
}
/***********************************************************************
* rr^2 = (x - xc)^2 + ee * (x - xc) (y - yc) + (1 + ff) * (y -yc)^2
* f(x,y) = hh / [ 1. + (rr * bb)^2 ]^qq 
* LBFGS version with bounded constraints on the parameters
*
* INPUT:
* image: array to be fitted
* nstars: number of stars to be fitted
* xx: first guess of the parameters for the Moffat profiles
* fp_log: pointer to logfile
*
* OUTPUT
* xx: parameters found for the Moffat profiles
************************************************************************/
static int fit_moffat_profile(double *xx, double *xc, double *yc, 
                              int circ_isoph, int qq_fixed, int constant_bck, 
                              double factr, double pgtol, int niter_max,
                              FILE *fp_log)
{
double fret, rms_resi;
double *lbound, *ubound, ipix;
int nn, *nbound;
register int m, k;

/* Allocate enough memory to fit extra parameters ee and ff: */
 nbound = (int *)malloc((3*nstars + 8) * sizeof(int));
 lbound = (double *)malloc((3*nstars + 8) * sizeof(double));
 ubound = (double *)malloc((3*nstars + 8) * sizeof(double));
/*
*  To provide nbound which defines the bounds on the variables:
*  nbound   specifies the number of bounds (0, 1, 2 or 3),
*  lbound   specifies the lower bounds,
*  ubound   specifies the upper bounds.
*
*    nbound(i)=0 if x(i) is unbounded,
*              1 if x(i) has only a lower bound,
*              2 if x(i) has both lower and upper bounds,
*              3 if x(i) has only an upper bound.
*/
/* xx array with the parameters (from 0 to 3*nstars + 7):
* For one star:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = bb, xx[8] = qq, xx[9] = ee, xx[10] = ff
*/
k = 0;

/* No bounds on s0, s1, s2, and s3: */
nbound[k] = 0; lbound[k] = ubound[k] = 0.;
k++;
if(!constant_bck) {
 nbound[k] = 0; lbound[k] = ubound[k] = 0.;
 k++;
 nbound[k] = 0; lbound[k] = ubound[k] = 0.;
 k++;
 }

/* ipix: accuracy on the guessed center in pixels */
ipix = 5.;
for(m = 0; m < nstars; m++) {
/* xc +/- ipix */
  nbound[k] = 2; 
  lbound[k] = xc[m] - ipix; 
  ubound[k] = xc[m] + ipix;
  k++;
/* yc +/- ipix */
  nbound[k] = 2;
  lbound[k] = yc[m] - ipix; 
  ubound[k] = yc[m] + ipix;
/* Lower bound only (hh must be positive) */
  k++;
  nbound[k] = 1;
  lbound[k] = 0.; 
  ubound[k] = 0.;
  k++;
 } /* EOF loop on m */
/* Lower bound only (bb must be positive) */
nbound[k] = 1;
lbound[k] = 0.; 
ubound[k] = 0.;
k++;
if(!qq_fixed) {
/* qq in the range [1., 2.] */
nbound[k] = 2;
lbound[k] = 1.; 
ubound[k] = 2.;
k++;
}
/* ee in the range [-0.5, 0.5] */
if(!circ_isoph) {
nbound[k] = 2;
lbound[k] = -0.5; 
ubound[k] = 0.5;
k++;
/* ff in the range [-0.5, 0.5] */
nbound[k] = 2;
lbound[k] = -0.5; 
ubound[k] = 0.5;
k++;
}
printf("Number of parameters: k=%d (nparams=%d)\n", k, nparams);
for (k = 0; k < nparams; k++) {
 printf("nbounds[%d]=%d low=%f up=%f\n", k, nbound[k], lbound[k], ubound[k]);
 }

nn = nparams;
/* Saving parameters to static variables (that will be used by moffat_func 
* and moffat_dfunc: */
circular_isoph = circ_isoph;
qq_is_fixed = qq_fixed;
constant_background = constant_bck;

 JLP_LBFGS(&nn, xx, lbound, ubound, nbound, &fret, &factr, &pgtol, 
           &niter_max, moffat_func, moffat_dfunc);

 rms_resi = sqrt(fret);
 printf(" Mean value of the residuals for the minimum: %.5g\n", rms_resi);
 fprintf(fp_log, " Mean value of the residuals for the minimum: %.5g\n", rms_resi);

 free(nbound);
 free(lbound);
 free(ubound);
return(0);
}
/**************************************************************
* Gradient of function to be minimized
*
* gradient of (1/ n)  * sum [ image[i,j] - moffat(i,j) ]^2 
*
* xx array with the parameters (from 0 to 3*nstars + 7):
* For one star:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = bb, xx[8] = qq, xx[9] = ee, xx[10] = ff
**************************************************************/
static void moffat_dfunc(double *xx, double *grad_xx)
{
double hh[NSTARS_MAX], xc[NSTARS_MAX], yc[NSTARS_MAX], ee, ff, bb, bb2, qq;
register int i, j, k, m;
double sum_s0, sum_s1, sum_s2, sum_s3;
double sum_xc, sum_yc, sum_hh, sum_bb, sum_qq, sum_ee, sum_ff;
double s0, s1, s2, s3, x, y, dx, dy, Am, Bm, rr2, rr; 
double fxxm, dfxxm, dfxx_bb, dfxx_qq, dfxx_ee, dfxx_ff, fxx; 

param_from_xx(xx, &s0, &s1, &s2, &s3, xc, yc, hh, &ee, &ff, &bb, &qq, nstars);
bb2 = SQUARE(bb);

/* Initialization (useful if return in case of error) */
for(k = 0; k < nparams; k++) {
 grad_xx[k] = 0.;
 }

/* Starting index (for d/dxc1 ...): */
if(constant_background) {
  k = 1;
  } else {
  k = 3;
  }

for(m = 0; m < nstars; m++) {
/************** d/dxc d/dyc d/dhh  *****************/
  sum_xc = 0.;
  sum_yc = 0.;
  sum_hh = 0.;
/* To avoid division by zero: */
  if(hh[m] == 0) hh[m] = 1.e-8;

  for (j = jmin; j < jmax; j++) {
    y = (double)j;
    dy = y - yc[m]; 
    for (i = imin; i < imax; i++) {
      x = (double)i;
      dx = x - xc[m]; 
      rr2 = SQUARE(dx) + ee * dx * dy + (1. + ff) * SQUARE(dy);
      if(rr2 < 0) {
        fprintf(stderr, "moffat_dfunc/Error: rr2=%f m=%d ee=%f ff=%f\n", 
                rr2, m, ee, ff);
        return; 
        }
      rr = sqrt(rr2);
      Am = 1. + rr2 * bb2;
/* fxxm = Moffat profile of index m */
      fxxm = hh[m] / pow( Am, qq);
      Bm = 2. * fxxm * qq * rr * bb / Am;
      fxx = profile_value(s0, s1, s2, s3, xc, yc, hh, bb2, qq, ee, ff, x, y);
/* d / d xc */
      if(rr != 0.) {
        dfxxm = -Bm * bb * (- 2. * x - ee * y + 2. * xc[m] + ee * yc[m]) 
               / (2. * rr);
        sum_xc += (image[i + j * idim] - fxx) * dfxxm;
/* d / d yc */
        dfxxm = -Bm * bb * (- x * ee - 2. * y * (1. + ff)
               + ee * xc[m] + 2. * (1. + ff) * yc[m]) / (2. * rr);
        sum_yc += (image[i + j * idim] - fxx) * dfxxm;
        }
/* d / d hh */
      dfxxm = fxxm / hh[m];
      sum_hh += (image[i + j * idim] - fxx) * dfxxm;
    }
  }
  grad_xx[k++] = -2. * sum_xc / (double)npts;
  grad_xx[k++] = -2. * sum_yc / (double)npts;
  grad_xx[k++] = -2. * sum_hh / (double)npts;
}

/******* d/dbb d/dqq d/dee d/dff *****************/
  sum_s0 = 0.;
  sum_s1 = 0.;
  sum_s2 = 0.;
  sum_s3 = 0.;
  sum_bb = 0.;
  sum_qq = 0.;
  sum_ee = 0.;
  sum_ff = 0.;
for (j = jmin; j < jmax; j++) {
  y = (double)j;
  for (i = imin; i < imax; i++) {
    x = (double)i;
    dfxx_bb = 0.;
    dfxx_qq = 0.;
    dfxx_ee = 0.;
    dfxx_ff = 0.;
/*************** Loop on all stars *****************/
    for(m = 0; m < nstars; m++) {
      dy = y - yc[m]; 
      dx = x - xc[m]; 
      rr2 = SQUARE(dx) + ee * dx * dy + (1 + ff) * SQUARE(dy);
      if(rr2 < 0) {
        fprintf(stderr, "moffat_dfunc/Error: rr2=%f ee=%f ff=%f\n", 
                rr2, ee, ff);
        return; 
        }
      rr = sqrt(rr2);
      Am = 1. + rr2 * bb2;
      fxxm = hh[m] / pow( Am, qq);
      Bm = 2. * fxxm * qq * rr * bb / Am;
      fxx = profile_value(s0, s1, s2, s3, xc, yc, hh, bb2, qq, ee, ff, x, y);
/* d / d bb */
      dfxx_bb += - Bm * rr;
/* d / d qq */
      dfxx_qq += - fxx * log(Am);
/* d / d ee */
      if(rr != 0.) {
        dfxx_ee += - Bm * bb * dx * dy / (2. * rr);
/* d / d ff */
        dfxx_ff += - Bm * bb * dy * dy / (2. * rr);
        }
     }  /* EOF loop on m=0, nstars */
     sum_s0 += (image[i + j * idim] - fxx);
     sum_s1 += (image[i + j * idim] - fxx) * x;
     sum_s2 += (image[i + j * idim] - fxx) * y;
     sum_s3 += (image[i + j * idim] - fxx) * x * y;
     sum_bb += (image[i + j * idim] - fxx) * dfxx_bb;
     sum_qq += (image[i + j * idim] - fxx) * dfxx_qq;
     sum_ee += (image[i + j * idim] - fxx) * dfxx_ee;
     sum_ff += (image[i + j * idim] - fxx) * dfxx_ff;
  } /* EOF loop on i */
}  /* EOF loop on j */

k = 0;
/* d / d s0 */ 
  grad_xx[k++] = -2. * sum_s0 / (double)npts;
  if(!constant_background) {
/* d / d s1 */ 
   grad_xx[k++] = -2. * sum_s1 / (double)npts;
/* d / d s2 */ 
   grad_xx[k++] = -2. * sum_s2 / (double)npts;
/* d / d s3 */ 
   grad_xx[k++] = -2. * sum_s3 / (double)npts;
   }
/* Now skip xc1,yc1,hh1,xc2,yc2,hh2,... */
k += nstars * 3;
/* d / d bb */ 
  grad_xx[k++] = -2. * sum_bb / (double)npts;

/* d / d qq */ 
if(!qq_is_fixed) grad_xx[k++] = -2. * sum_qq / (double)npts;

if(!circular_isoph){
/* d / d ee */ 
  grad_xx[k++] = -2. * sum_ee / (double)npts;
/* d / d ff */ 
  grad_xx[k++] = -2. * sum_ff / (double)npts;
}

#ifdef DEBUGG
 for(i = 0; i < nparams; i++) printf("gradx[%d]=%.3g ", i, grad_xx[i]);
 printf("\n");
#endif

return;
}
/**************************************************************
* Function to be minimized:
*
* value = (1/ n)  * sum [ image[i,j] - Sum_N moffat_m(i,j) - sky]^2 
*
* sky = s0 + s1 * x + s2 * y + s3 * x * y
*
* xx array with the parameters (from 0 to 3*nstars + 7):
* For one star:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = bb, xx[8] = qq, xx[9] = ee, xx[10] = ff
**************************************************************/
static double moffat_func(double *xx) 
{
double s0, s1, s2, s3, ee, ff, bb, bb2, qq, x, y;
double fxx, sumsq, bad_value=1000., value; 
double hh[NSTARS_MAX], xc[NSTARS_MAX], yc[NSTARS_MAX];
int jj;
register int i, j;

param_from_xx(xx, &s0, &s1, &s2, &s3, xc, yc, hh, &ee, &ff, &bb, &qq, nstars);

/* Constraints:
* bb=xx[3*nstars + 3] should be positive! 
* qq=xx[3*nstars + 4] should belong to [1., 2.] 
* ee=xx[3*nstars + 5] and ff=xx[3*nstars + 6] should belong to [-1,1] 
* Puts a negative gradient to increase the parameter, 
* i.e., a larger value would be more favorable
* since it would lead to a smaller residual: 
* or positive otherwise
*/
  if(qq < 0.5 || qq > 5. || ABS(ee) > 1. || ABS(ff) > 1.) {
#ifdef DEBUG
   printf("moffat_dfunc/Warning, bad values found: bb=%f qq=%f ee=%f ff=%f\n", 
           bb, qq, ee, ff);
#endif
   return(bad_value);
   }

sumsq = 0.;
bb2 = SQUARE(bb);

for (j = jmin; j < jmax; j++) {
  jj = j * idim;
  y = (double)j;
  for (i = imin; i < imax; i++) {
    x = (double)i;
    fxx = profile_value(s0, s1, s2, s3, xc, yc, hh, bb2, qq, ee, ff, x, y); 
    sumsq += SQUARE(image[i + jj] - fxx);
  }
}
value = sumsq / (double)npts;

#ifdef DEBUGG
printf(" moffat_func: value=%.5g npts=%d\n", value, npts);
#endif
return(value);
}
/**********************************************************************
* Compute the theoretical profile value 
* compatible with the current set of parameters
*
* fxx = hh[m] / pow(( 1. + rm2 * bb2), qq) + s0 + s1 * x + s2 * y + s3 * x * y
**********************************************************************/
static double profile_value(double s0, double s1, double s2, double s3,
                            double *xc, double *yc, double *hh, double bb2, 
                            double qq, double ee, double ff, double x, 
                            double y) 
{
double rm2, fxx, dx, dy;
register int m;

    fxx = 0.;
    for(m = 0; m < nstars; m++) {
      dx = x - xc[m];
      dy = y - yc[m];
      rm2 = SQUARE(dx) + ee * dx * dy + (1. + ff) * SQUARE(dy);
/* In case of negative radius, return "bad_value": */
      if(rm2 < 0) {
       fprintf(stderr,"objective_function/Fatal error: negative radius!\n");
       exit(-1);
      }
      fxx += hh[m] / pow(( 1. + rm2 * bb2), qq);
    } 
    fxx += s0 + s1 * x + s2 * y + s3 * x * y;
return(fxx);
}
/**********************************************************************
* Load the parameters from the xx array: 
*
* xx array with the parameters (from 0 to 3*nstars + 7):
* For one star:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = bb, xx[8] = qq, xx[9] = ee, xx[10] = ff
* For two stars:
* xx[0] = s0,  xx[1] = s1, xx[2] = s2, xx[3] = s3,
* xx[4] = xc[0], xx[5] = yc[0], xx[6] = hh[0],
* xx[7] = xc[0], xx[8] = yc[0], xx[9] = hh[0],
* xx[10] = bb, xx[11] = qq, xx[12] = ee, xx[13] = ff
* nparams = 3*nstars + 5 if circular isophotes and qq fixed
* nparams = 3*nstars + 6 if circular isophotes and qq free
* nparams = 3*nstars + 8 if elliptical isophotes and qq free
***********************************************************************/
static int param_from_xx(double *xx, double *s0, double *s1, double *s2,
                         double *s3, double *xc, double *yc, double *hh, 
                         double *ee, double *ff, double *bb, double *qq, 
                         int nstars)
{
register int k, m;

k = 0;
*s0 = xx[k++];
if(constant_background) {
  *s1 = 0.;
  *s2 = 0.;
  *s3 = 0.;
  } else {
  *s1 = xx[k++];
  *s2 = xx[k++];
  *s3 = xx[k++];
  }
for(m = 0; m < nstars; m++) {
  xc[m] = xx[k++];
  yc[m] = xx[k++];
  hh[m] = xx[k++];
#ifdef DEBUGG
printf(" Star#%d xc=%.3f yc=%.3f hh=%.3f ", m, xc[m], yc[m], hh[m]);
#endif
  }
*bb = xx[k++];
if(qq_is_fixed) {
  *qq = qq_value; 
  } else {
  *qq = xx[k++];
  }
/* If circular isophotes, assumes ee=ff=0: */
if(!circular_isoph) {
  *ee = xx[k++];
  *ff = xx[k++];
  } else {
  *ee = 0.;
  *ff = 0.;
  }

#ifdef DEBUG
printf("s0=%.3f xc0=%.3g yc0=%.3g hh0=%.3g xc1=%.3g yc1=%.3g hh1=%.3g\n", 
        *s0, xc[0], yc[0], hh[0], xc[1], yc[1], hh[1]); 
#endif

return(0);
}
/**************************************************************
* Check the validity of the gradient
* and compare f(x+dx)-f(x)/dx with grad_f(x)
*
* x1,x2,dx: work space of dimension nparams+1 
**************************************************************/
static int check_grad(double *x1, int nparams, double (*func)(double []), 
                      void (*dfunc)(double[], double[]))
{
double *x2, *dx;
register int i, j;
double eps=1.e-4, tolerance=1.e-2;
double f_x2, f_x1, error, relative_error;

if( (x2 = (double *)malloc((3*nstars + 8) * sizeof(double))) == NULL
    || (dx = (double *)malloc((3*nstars + 8) * sizeof(double))) == NULL)
  {
   printf("check_grad/Fatal error allocating memory: dim=%d\n",
           3*nstars + 7);
   exit(-1);
  }

printf(" check_grad/Start checking gradient \n");

/* Generate random vector (between 0 and 1) 
* not used here yet
for(i = 0; i < nparams; i++) x1[i] = (double)rand() / (double)RAND_MAX;
*/

f_x1 = (*func)(x1); 

/* Loop on all the components: */
for(i = 0; i < nparams; i++)
   {
   for(j = 0; j < 3*nstars + 7; j++) x2[j] = x1[j];
/* Small variation of component #i: */
   x2[i] = x1[i] + eps;
   f_x2 = (*func)(x2); 
   (*dfunc)(x1,dx);
   error = (f_x2 - f_x1)/eps - dx[i];
/* Relative error: (error with "abs", OK with "ABS") */
   relative_error = error / (ABS(dx[i]) + 1.e-12);
#ifdef DEBUG
   printf("x1[%d]=%.3f f_x1=%.3e f_x2=%.3e (f_x2 - f_x1)/eps=%e dx[i]=%e error=%e (relative=%e)\n",
            i, x1[i], f_x1, f_x2, (f_x2 - f_x1)/eps, dx[i], error, relative_error);
#endif
    if(relative_error > tolerance) {
      printf("check_grad/Error! \n");
      printf("component #i=%d:  dx=%.4e relative error =%.4e\n\n", i, 
              dx[i], relative_error);
      }
   }

printf("check_grad/gradient is OK. \n");

free(x2);
free(dx);
return(0);
}
/***************************************************************************
* Input from X11 dialog box
*
* OUTPUT:
* filename: name of the file containing the input image
* n_stars: number of stars to be fitted
* xc[], yc[], hh[]: coordinates of the center (in pixels) and central brightness
*                   for each star
* fwhm: FWHM seeing (in pixels)
* qq: value of the exponent of the Moffat profile
* factr: tolerance factor on the residuals (criterium to stop minimisation)
* pgtol: fit tolerance on the gradient (criterium to stop minimisation)
* is_OK: 1 if the user has pressed on OK
*        0 if the user has pressed on Cancel 
***************************************************************************/
static int input_from_dialog_box(char *filename, int *n_stars, double *xc, 
                             double *yc, double *qq, int *qq_fixed, 
                             int *circ_isoph, int *constant_bck,
                             double *fwhm, double *factr, 
                             double *pgtol, int *niter_max, int *is_OK)
{
int is_ok, nwidgets, small_size;
JLP_GDlg *JDlg0;
char label[NN][80], svalue[NN][80], val_type[NN];
int widget_type[NN], radio_group[NN], is_checked[NN];
register int i, m;

for(i = 0; i < NN; i++) {
  widget_type[i] = 0;
  radio_group[i] = -1;
  label[i][0] = '\0';
  svalue[i][0] = '\0';
  is_checked[i] = 0;
  val_type[i] = 'c';
  }

// Edit button:
i = 0;
widget_type[i] = 4;
strcpy(label[i], "Input image filename:");
val_type[i] = 'c';
strcpy(svalue[i], filename);


// Edit button:
i = 1;
widget_type[i] = 4;
strcpy(label[i], "Number of stars to be fitted:");
val_type[i] = 'd';
sprintf(svalue[i],"%d", *n_stars);

// ******************** Static label:
i = 2;
widget_type[i] = 1;
strcpy(label[i], "====== Approximative centers for the stars =======");

// Edit buttons:
// xc_1=sval[3] yc_1=sval[4] 
i = 3;
widget_type[i] = 4;
strcpy(label[i], "x-center (1):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",83.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (1):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",64.);

// Edit buttons:
// xc_2=sval[5] yc_2=sval[6] 
i = 5;
widget_type[i] = 4;
strcpy(label[i], "x-center (2):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",43.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (2):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",65.);

// Edit buttons:
// xc_3=sval[7] yc_3=sval[8] 
i = 7;
widget_type[i] = 4;
strcpy(label[i], "x-center (3):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",64.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (3):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",64.);

// ******************** Static label:
i = 9;
widget_type[i] = 1;
strcpy(label[i], "======= Parameters for Moffat profile ======");

// Edit button:
i = 10;
widget_type[i] = 4;
strcpy(label[i], "Value of q:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",1.4);

// Check button:
i = 11;
widget_type[i] = 2;
strcpy(label[i], "Fixed value of q");
is_checked[i] = 1;

// Radio Buttons:
i = 12;
widget_type[i] = 3;
radio_group[i] = 0;
strcpy(label[i], "Circular isophotes");
strcpy(svalue[i], "----- Geometry: -----");
if(*circ_isoph) is_checked[i] = 1;
  else is_checked[i] = 0;

i++;
widget_type[i] = 3;
radio_group[i] = 0;
strcpy(label[i], "Elliptical isophotes");
if(*circ_isoph) is_checked[i] = 0;
  else is_checked[i] = 1;

// Edit button:
i = 14;
widget_type[i] = 4;
strcpy(label[i], "FWHM seeing (pixels):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",5.0);

// Radio Buttons:
i = 15;
widget_type[i] = 3;
radio_group[i] = 1;
strcpy(label[i], "Constant");
strcpy(svalue[i], "---- Sky background: ----");
if(*constant_bck) is_checked[i] = 1;
  else is_checked[i] = 0;

i++;
widget_type[i] = 3;
radio_group[i] = 1;
strcpy(label[i], "First-order polynomial");
if(*constant_bck) is_checked[i] = 0;
  else is_checked[i] = 1;

// ******************** Static label:
i = 17;
widget_type[i] = 1;
strcpy(label[i], "========== Parameters for the fit ==========");

// Edit button:
i = 18;
widget_type[i] = 4;
strcpy(label[i], "factr:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1e",*factr);

i++;
widget_type[i] = 4;
strcpy(label[i], "pgtol:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1e",*pgtol);

i++;
widget_type[i] = 4;
strcpy(label[i], "Max. number of iterations:");
val_type[i] = 'd';
sprintf(svalue[i],"%d",*niter_max);

nwidgets = i+1;

// Open new DialogBox (with big size) 
// Needs splot/lib library compiled with "JLP_USE_X11" 
small_size = 0;
JDlg0 = new JLP_GDlg_X11("Parameters for fit_moffat", small_size);

// Create the widgets:
JDlg0->CreateWidgets(label, widget_type, radio_group, val_type,
                     svalue, is_checked, nwidgets);

JDlg0->WaitForOK(svalue, is_checked, nwidgets, is_ok);

delete JDlg0;


for(i = 0; i < nwidgets; i++) {
  printf("Output from Dialog Box: svalue[%d]=%s, is_checked=%d\n",
         i,svalue[i], is_checked[i]);
  }

*is_OK = is_ok;

strcpy(filename, svalue[0]);
sscanf(svalue[1],"%d",n_stars);
sscanf(svalue[3],"%lf",&xc[0]);
sscanf(svalue[4],"%lf",&yc[0]);
sscanf(svalue[5],"%lf",&xc[1]);
sscanf(svalue[6],"%lf",&yc[1]);
sscanf(svalue[7],"%lf",&xc[2]);
sscanf(svalue[8],"%lf",&yc[2]);
sscanf(svalue[10],"%lf",qq);
if(is_checked[11]) 
  *qq_fixed = 1;
else 
  *qq_fixed = 0;
if(is_checked[12]) 
  *circ_isoph = 1;
else 
  *circ_isoph = 0;
sscanf(svalue[14],"%lf",fwhm);
if(is_checked[15]) 
  *constant_bck = 1;
else 
  *constant_bck = 0;
sscanf(svalue[18],"%le",factr);
sscanf(svalue[19],"%le",pgtol);
sscanf(svalue[20],"%d",niter_max);

printf("input_from_dialog_box/ filename=%s, nstars=%d\n", filename, nstars); 
for(m = 0; m < nstars; m++)
   printf(" xc[%d]=%.2f yc[%d]=%.2f \n", m, xc[m], m, yc[m]);
printf("circ=%d fwhm=%.2f constant_bck=%d\n",
        *circ_isoph, *fwhm, *constant_bck);
printf("factr=%e pgtol=%e niter=%d is_OK=%d\n",
        *factr, *pgtol, *niter_max, *is_OK);

return(0);
}
/***************************************************************************
* Input from parameter file 
*
* OUTPUT:
* param_file: name of the file containing the input parameters to be read
* filename: name of the file containing the input image
* n_stars: number of stars to be fitted
* xc[], yc[], hh[]: coordinates of the center (in pixels) and central brightness
*                   for each star
* fwhm: FWHM seeing (in pixels)
* qq: value of the exponent of the Moffat profile
* factr: tolerance factor on the residuals (criterium to stop minimisation)
* pgtol: fit tolerance on the gradient (criterium to stop minimisation)
* is_OK: 1 if the user has pressed on OK
*        0 if the user has pressed on Cancel 
***************************************************************************/
static int input_from_file(char *param_file, char *filename, int *n_stars, 
                           double *xc, double *yc, double *qq, int *qq_fixed, 
                           int *circ_isoph, int *constant_bck, double *fwhm, 
                           double *factr, double *pgtol, int *niter_max, 
                           int *is_OK)
{
int is_ok = 1, ival;
FILE *fp_in;
char buffer[80];

if((fp_in = fopen(param_file,"r")) == NULL) {
 fprintf(stderr, "input_from_file/Error opening input parameter file!\n");
 return(-1);
 }

/************* Main loop **************************************/
while(!feof(fp_in)) {

/* Read a new line from input file: */
 if(!fgets(buffer, 80, fp_in)) break;

/* Decode this line if it is not a comment (starting with % or #): */
if(buffer[0] != '#' && buffer[0] != '%') {

if(!strncmp(buffer, "Input", 5)) {
  sscanf(buffer, "Input image: %s", filename);
} else if(!strncmp(buffer, "Number", 6)) { 
  if((ival = sscanf(buffer, "Number of stars: %d", n_stars)) != 1) {
    fprintf(stderr, "input_from_file/Error reading number of stars!\n");
    is_ok = 0;
    } 
} else if(!strncmp(buffer, "Center1", 7)) { 
if((ival = sscanf(buffer, "Center1: %lf,%lf", &xc[0], &yc[0])) != 2) {
 fprintf(stderr, "input_from_file/Error reading center (1) coordinates!\n");
 is_ok = 0;
 }
} else if(!strncmp(buffer, "Center2", 7)) { 
if((ival = sscanf(buffer, "Center2: %lf,%lf", &xc[1], &yc[1])) != 2) {
 fprintf(stderr, "input_from_file/Error reading center (2) coordinates!\n");
 is_ok = 0;
 }
} else if(!strncmp(buffer, "Center3", 7)) { 
if((ival = sscanf(buffer, "Center3: %lf,%lf", &xc[2], &yc[2])) != 2) {
 fprintf(stderr, "input_from_file/Error reading center (3) coordinates!\n");
 is_ok = 0;
 }
} else if(!strncmp(buffer, "Moffat", 6)) { 
 sscanf(buffer, "Moffat parameter q: %lf", qq);
} else if(!strncmp(buffer, "q is", 4)) { 
 sscanf(buffer, "q is fixed (0=free or 1=fixed): %d", qq_fixed); 
} else if(!strncmp(buffer, "FWHM", 4)) { 
 sscanf(buffer, "FWHM (pixels): %lf", fwhm);
} else if(!strncmp(buffer, "Isophotes", 9)) { 
 sscanf(buffer, "Isophotes (0=elliptical 1=circular): %d", circ_isoph); 
} else if(!strncmp(buffer, "Background", 10)) { 
 sscanf(buffer, "Background (0=polynomial 1=constant): %d", constant_bck); 
} else if(!strncmp(buffer, "Fit", 3)) { 
 if((ival = sscanf(buffer, "Fit param. (factr, pgtol, max_niter): %lf,%lf,%d", 
       factr, pgtol, niter_max)) != 3) {
 fprintf(stderr, "input_from_file/Error reading fit parameters!\n");
 is_ok = 0;
 }
} /* EOF strncmp */
} /* EOF case (buffer[0] != '#') */
} /* EOF while fgets != feof*/

*is_OK = is_ok;

fclose(fp_in);

return(0);
}
/***********************************************************************
* Setting the limits in the image for fitting the Moffat profiles
*
***********************************************************************/
static int set_limits(double *xc, double *yc, int *imin, int *imax, int *jmin, 
                      int *jmax, int nstars, int nx, int ny, double fwhm)
{
int iwid, ix, iy, ixmin, ixmax, iymin, iymax;
register int m;

/* Should take a large window to estimate correctly the wings of the profile
*/
// iwid = NINT(24. * fwhm);
 iwid = NINT(100. * fwhm);

 ixmin = NINT(xc[0]);
 ixmax = ixmin; 
 iymin = NINT(yc[0]);
 iymax = iymin; 

 for(m = 0; m < nstars; m++) {
   ix = NINT(xc[0]);
   ixmin = MINI(ix, ixmin);
   ixmax = MAXI(ix, ixmax);
   iy = NINT(yc[0]);
   iymin = MINI(iy, iymin);
   iymax = MAXI(iy, iymax);
   }

 *imin = MAXI(0, ixmin - iwid);
 *imax = MINI(nx, ixmax + iwid); 
 *jmin = MAXI(0, iymin - iwid);
 *jmax = MINI(ny, iymax + iwid); 

printf("set_limits/imin=%d imax=%d jmin=%d jmax=%d\n", 
        *imin, *imax, *jmin, *jmax);
return(0);
}
/**************************************************************************
*
*
**************************************************************************/
static int compute_residuals(float *image, int nx, int ny, int idim,
                             char *input_filename,
                             double s0, double s1, double s2, double s3, 
                             double bb, double qq, double ee, double ff, 
                             double *xc, double *yc, double *hh)
{
register int i, j;
int jj;
double fxx, bb2, x, y, xc_frame, yc_frame;
char filename[80], comments[128];
float *model, *smodel;

#ifdef TTT
s0 = 2.0;
s1 = 0.;
s2 = 0.;
s3 = 0.;
xc[0] = 84.0;
yc[0] = 64.0;
hh[0] = 10.0;
xc[1] = 44.;
yc[1] = 64.;
hh[1] = 10.0;
bb = 0.20;
qq = 1.5000;
ee = 0.0;
ff = 0.0;
#endif

bb2 = bb * bb;

model = new float[nx*ny];

for(j = 0; j < ny; j++) {
  jj = j * idim; 
  y = (double)j;
  for(i = 0; i < nx; i++) {
    x = (double)i;
    fxx = profile_value(s0, s1, s2, s3, xc, yc, hh, bb2, qq, ee, ff, x, y);
    model[i + jj] = fxx;
    image[i + jj] -= fxx;
  }
}

/* High resolution model (magnified 4 times and centered on the first star): */
smodel = new float[nx*ny];
yc_frame = ((double)ny)/2.;
xc_frame = ((double)nx)/2.;
for(j = 0; j < ny; j++) {
  jj = j * nx; 
  y = yc[0] + ((double)j - yc_frame) / 4.;
  for(i = 0; i < nx; i++) {
    x = xc[0] + ((double)i - xc_frame) / 4.;
    fxx = profile_value(s0, s1, s2, s3, xc, yc, hh, bb2, qq, ee, ff, x, y);
    smodel[i + jj] = fxx;
  }
}

 

sprintf(comments,"s0=%.2e b=%.2f q=%.2f e=%.1f f=%.1f (%.1f %.1f %.2e) (%.1f %.1f %.2e)", 
        s0, bb, qq, ee, ff, xc[0], yc[0], hh[0],
         xc[1], yc[1], hh[1]);
strcpy(filename,"moffat_model");
JLP_WRITEIMAG(model, &nx, &ny, &nx, filename, comments);

strcpy(filename,"moffat_model_4x");
JLP_WRITEIMAG(smodel, &nx, &ny, &nx, filename, comments);

sprintf(comments,"Residuals from %s", input_filename);
strcpy(filename,"moffat_resi");
JLP_WRITEIMAG(image, &nx, &ny, &nx, filename, comments);

delete model;
delete smodel;

return (0);
}
