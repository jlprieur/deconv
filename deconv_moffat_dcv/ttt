/****************************************************************** 
* fit_merate
* Program to obtain astrometry of close binaries
* from autocorrelations
*
* Subtract a model of the central peak
* f(x,y) = hh1 * gauss(xc1, yc1, sig1) + hh2 * gauss(xc2, yc2, sig2)
*          + aa * model + s0
*
* JLP
* Version 19/01/2007
*******************************************************************/ 
#include "jlp_ftoc.h"
#include "../splot/lib/jlp_dialog.h"
#include "../splot/lib/jlp_dlg_x11.h"


#define NN 60

#define DEBUG
/*
#define CHECK_GRAD 
#define DEBUGG
*/
#define NSTARS_MAX 2

/*
* i_min, i_max, j_min, j_max: coordinates (in pixels) of the area to be used
*                             in the input image
*/
static int nstars, nparams, idim, npts;
static int imin[NSTARS_MAX], imax[NSTARS_MAX], jmin[NSTARS_MAX], jmax[NSTARS_MAX]; 
static float *autoc_data, *back_model;

/******************* Prototypes: ****************************/

/* Declaring linkage specification to have "correct names"
* that can be linked with C programs */

#ifdef __cplusplus
extern "C" {
#endif

/* In "../math/lbfgs_bcm/dcv_lbfgs.c" */
int JLP_LBFGS(int *n, double *x, double *lbound, double *ubound,
              int *nbound, double *f, double *ftol, double *pgtol,
              int *niter_max, double (*func)(double *),
              void (*dfunc)(double *, double *));

#ifdef __cplusplus
}
#endif


/* Defined here: */
static int interactive_input(char *autoc_fname, char *back_fname,
                             char *resid_fname, int *n_stars, double *xc, 
                             double *yc, double *fwhm, double *factr, 
                             double *pgtol, int *niter_max, int *is_OK);
static int symmetrize_residuals(float *resid, int nx, int ny, int idim);
static double model1_value(double s0, double aa, double bb2, double *xc, 
                          double *yc, double *hh, int ix, int iy);
static int fit_model1(double *xx, double *xc, double *yc, double factr, 
                      double pgtol, int niter_max);
static double model1_func(double *xx);
static void model1_dfunc(double *xx, double *dx);
static int param_from_xx(double *xx, double *s0, double *aa, double *bb, 
                         double *xc, double *yc, double *hh, int nstars);
static int check_grad(double *x1, int nparams, double (*func)(double []), 
                      void (*dfunc)(double[], double[]));
static int set_limits(double *xc, double *yc, int nstars, double fwhm);
static int compute_residuals(float *autoc_data, float *model, int nx, int ny, 
                             int idim, double s0, double aa, double bb, 
                             double *xc, double *yc, double *hh);

int main(int argc, char *argv[])
{
int status, interactive, is_OK, niter_max; 
INT_PNTR pntr;
INT4 nx, ny, nx1, ny1;
float *model;
double *xx, factr, pgtol; 
double xc[NSTARS_MAX], yc[NSTARS_MAX], hh[NSTARS_MAX]; 
double fwhm, aa, bb, s0; 
register int i, j, k, m;
char autoc_fname[60], back_fname[60], resid_fname[60];
char comments[80], param_file[60];

printf(" Program to fit a model to compute astrometry from autocorrelations\n");
printf(" JLP version 22/01/2007\n");

/* Reduce the number of arguments when "runs" is used and  argc=7 */
if(argc == 7)
 {
 for(i = 6; i > 0; i--)
  {
   if(*argv[i] == ' ' || *argv[i] == '\0')argc--;
   else break;
  }
 }

/* Default values: */
interactive = 1;
nstars = 2;

/*     factr is a DOUBLE PRECISION variable that must be set by the user.
c       It is a tolerance in the termination test for the algorithm.
c       The iteration will stop when
c
c        (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
c
c       where epsmch is the machine precision which is automatically
c       generated by the code. Typical values for factr on a computer
c       with 15 digits of accuracy in double precision are:
c       factr=1.e+12 for low accuracy;
c             1.e+7  for moderate accuracy;
c             1.e+1  for extremely high accuracy.
c       The user can suppress this termination test by setting factr=0.
c
c     pgtol is a double precision variable.
c       On entry pgtol >= 0 is specified by the user.  The iteration
c         will stop when
c
c                 max{|proj dx_i | i = 1, ..., n} <= pgtol
c
c         where proj dx_i is the ith component of the projected gradient.
c       The user can suppress this termination test by setting pgtol=0.
*/
factr = 1.e+1;
pgtol = 1.e-9;
niter_max = 2000;
autoc_fname[0] = '\0';
strcpy(back_fname, "unres_d_patched");
strcpy(resid_fname, "merate_resid");

if(argc > 1)
{
sscanf(argv[1],"%s", autoc_fname);
if(argc > 2) {
  sscanf(argv[2],"%s", param_file);
  interactive = 0;
  }
}
else
{
printf(" Usage: fit_merate autoc_fname [param_file] \n");
/*
exit(-1);
*/
}

/* Display popup window with default values: */
if(interactive) {
  interactive_input(autoc_fname, back_fname, resid_fname, &nstars, xc, yc, 
                   &fwhm, &factr, &pgtol, &niter_max, &is_OK);
  bb = 2. / fwhm;
#ifdef DEBUG
printf(" fwhm=%f bb=%f\n", fwhm, bb);
#endif
  if(!is_OK) exit(-1);
}

printf("OK: autoc=%s nstars=%d factr=%e pgtol=%e\n", 
        autoc_fname, nstars, factr, pgtol);

if(nstars < 0 || nstars > NSTARS_MAX) {
 fprintf(stderr, "fit_merate/Fatal error invalid value for nstars (=%d !) \n",
         nstars);
 exit(-1);
 }

/* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
* For two stars:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
* xx[6] = xc[1], xx[7] = yc[1], xx[8] = hh[1],
* nparams = 3*nstars + 3
*/

/* s0, aa, bb, and (xc, yc, hh)*nstars */
 nparams = 3*nstars + 3;

/* Allocate memory for xx: */
if((xx = (double *)malloc((3*nstars + 3) * sizeof(double))) == NULL) {
 fprintf(stderr, "fit_merate/Fatal error allocating memory space for xx\n");
  exit(-1);
 }

JLP_INQUIFMT();

/* Read input images: autoc_data and back_model 
*/
status = JLP_VM_READIMAG1(&pntr, &nx, &ny, autoc_fname, comments);
if(status) exit(-1);
autoc_data = (float *) pntr;
idim = nx;

status = JLP_VM_READIMAG1(&pntr, &nx1, &ny1, back_fname, comments);
if(status) exit(-1);
back_model = (float *) pntr;
if(nx1 != nx || ny1 != nx) {
  printf("fit_merate/fatal error: inconsistent sizes: nx=%d ny=%d nx1=%d ny1=%d\n",
          nx, ny, nx1, ny1);
  exit(-1);
  }

/* First guess: aa=0.1; 
*/
aa = 0.1;

/* Sky value estimated at the corners of (autoc_data - back_model): */
k = 0;
/* s0 */
s0 = (autoc_data[0] + autoc_data[nx - 1] + autoc_data[nx - 1 + (ny - 1)*idim]
     + autoc_data[(ny -1)*idim]
    - aa * (back_model[0] + back_model[nx - 1] + back_model[nx - 1 + (ny - 1)*idim]
     + back_model[(ny -1)*idim]) ) / 4.;

/* Central brightness hh is taken equal to the autoc_data value 
* at the location (xc, yc): 
*/
for(m = 0; m < nstars; m++) {
  i = NINT(xc[m]) + NINT(yc[m]) * idim ;
  hh[m] = autoc_data[i] - aa * back_model[i] - s0; 
  }

/*
* For one star:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
*/
if(interactive) {
  k = 0;
  xx[k++] = s0;
  xx[k++] = aa;
  xx[k++] = bb;
  for(m = 0; m < nstars; m++) {
    xx[k++] = xc[m]; 
    xx[k++] = yc[m]; 
    xx[k++] = hh[m];
    }
} else {
printf("Parameter file: not yet implemented \n");
exit(-1);
}

#ifdef DEBUG
printf("k=%d nparams=%d\n", k, nparams);
for(i = 0; i < nparams; i++) 
   printf("Initialisation/xx[%d] = %f\n", i, xx[i]);
#endif

 set_limits(xc, yc, nstars, fwhm);
 npts = nx * ny; 

/* Possibility of checking that the gradient is OK: */
#ifdef CHECK_GRAD 
status = check_grad(xx, nparams, model1_func, model1_dfunc);
if(status != 12345) return(0);
#endif

status = fit_model1(xx, xc, yc, factr, pgtol, niter_max);

printf(" Solution with factr=%e and pgtol=%e is: (with npts=%d)\n", 
         factr, pgtol, npts);

/* Compute values of parameters from solution vector xx: */
param_from_xx(xx, &s0, &aa, &bb, xc, yc, hh, nstars);

for(m = 0; m < nstars; m++) 
    printf(" Star#%d xc=%f yc=%f hh=%f\n", m, xc[m], yc[m], hh[m]);

fwhm = 2. / bb;
printf(" s0=%f aa=%f bb=%f (fwhm=%f)\n", s0, aa, bb, fwhm);

model = (float *)malloc(nx * ny * sizeof(float));

compute_residuals(autoc_data, model, nx, ny, nx, s0, aa, bb, xc, yc, hh);

sprintf(comments,"Residuals from %s", autoc_fname);
JLP_WRITEIMAG(autoc_data, &nx, &ny, &nx, resid_fname, comments);

symmetrize_residuals(autoc_data, nx, ny, nx);

sprintf(comments,"Symmetric version of %s", resid_fname);
strcpy(resid_fname, "merate_resi_sym.fits");
JLP_WRITEIMAG(autoc_data, &nx, &ny, &nx, resid_fname, comments);

sprintf(comments,"Fitted model to %s", autoc_fname);
strcpy(resid_fname, "merate_model.fits");
JLP_WRITEIMAG(model, &nx, &ny, &nx, resid_fname, comments);

free(xx);
free(model);
return(0);
}
/***********************************************************************
* LBFGS version with bounded constraints on the parameters
*
* INPUT:
* autoc_data: array to be fitted
* nstars: number of stars to be fitted
* xx: first guess of the parameters for the model 
*
* OUTPUT
* xx: parameters found for the model 
************************************************************************/
static int fit_model1(double *xx, double *xc, double *yc, double factr, 
                       double pgtol, int niter_max)
{
double fret, rms_resi;
double *lbound, *ubound, ipix;
int nn, *nbound;
register int m, k;

/* Allocate enough memory to fit all parameters: */
 nbound = (int *)malloc((3*nstars + 8) * sizeof(int));
 lbound = (double *)malloc((3*nstars + 8) * sizeof(double));
 ubound = (double *)malloc((3*nstars + 8) * sizeof(double));
/*
*  To provide nbound which defines the bounds on the variables:
*  nbound   specifies the number of bounds (0, 1, 2 or 3),
*  lbound   specifies the lower bounds,
*  ubound   specifies the upper bounds.
*
*    nbound(i)=0 if x(i) is unbounded,
*              1 if x(i) has only a lower bound,
*              2 if x(i) has both lower and upper bounds,
*              3 if x(i) has only an upper bound.
*/
/* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
*/
k = 0;

/* No bounds on s0, aa: */
nbound[k] = 0; lbound[k] = ubound[k] = 0.;
k++;
nbound[k] = 0; lbound[k] = ubound[k] = 0.;
k++;
/* Lower bound only (bb must be positive) */
nbound[k] = 1; lbound[k] = 0.; ubound[k] = 0.;
k++;

/* ipix: accuracy on the guessed center in pixels */
ipix = 5.;
for(m = 0; m < nstars; m++) {
/* xc +/- ipix */
  nbound[k] = 2; 
  lbound[k] = xc[m] - ipix; 
  ubound[k] = xc[m] + ipix;
  k++;
/* yc +/- ipix */
  nbound[k] = 2;
  lbound[k] = yc[m] - ipix; 
  ubound[k] = yc[m] + ipix;
/* Lower bound only (hh must be positive) */
  k++;
  nbound[k] = 1; lbound[k] = 0.; ubound[k] = 0.;
  k++;
 } /* EOF loop on m */
printf("Number of parameters: k=%d (nparams=%d)\n", k, nparams);
for (k = 0; k < nparams; k++) {
 printf("nbounds[%d]=%d low=%f up=%f\n", k, nbound[k], lbound[k], ubound[k]);
 }

nn = nparams;
 JLP_LBFGS(&nn, xx, lbound, ubound, nbound, &fret, &factr, &pgtol, 
           &niter_max, model1_func, model1_dfunc);

 rms_resi = sqrt(fret);
 printf(" Mean value of the residuals for the minimum: %.5g\n", rms_resi);

 free(nbound);
 free(lbound);
 free(ubound);
return(0);
}
/**************************************************************
* Gradient of function to be minimized
*
* gradient of (1/ n)  * sum [ autoc_data[i,j] - merate(i,j) ]^2 
*
* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
**************************************************************/
static void model1_dfunc(double *xx, double *grad_xx)
{
double hh[NSTARS_MAX], xc[NSTARS_MAX], yc[NSTARS_MAX]; 
double s0, aa, bb, bb2;
register int i, j, k, m;
double sum_s0, sum_aa, sum_bb, sum_xc, sum_yc, sum_hh;
double x, y, dx, dy, rr2, fxxm, dfxxm, dfxx_bb, fxx; 
int jj;

param_from_xx(xx, &s0, &aa, &bb, xc, yc, hh, nstars);
bb2 = SQUARE(bb);

/* Initialization (useful if return in case of error) */
for(k = 0; k < nparams; k++) {
 grad_xx[k] = 0.;
 }

/******* d/ds0 d/daa d/dbb *****************/
  sum_s0 = 0.;
  sum_aa = 0.;
  sum_bb = 0.;
for (j = jmin; j < jmax; j++) {
  y = (double)j;
  jj = j * idim;
  for (i = imin; i < imax; i++) {
    x = (double)i;
    dfxx_bb = 0.;
/*************** Loop on all stars *****************/
    for(m = 0; m < nstars; m++) {
      dy = y - yc[m]; 
      dx = x - xc[m]; 
      rr2 = SQUARE(dx) + SQUARE(dy);
      fxxm = hh[m] * exp( - rr2 * bb2);
/* d / d bb */
      dfxx_bb += fxxm * (-2. * bb * rr2); 
     }  /* EOF loop on m=0, nstars */
     fxx = model1_value(s0, aa, bb2, xc, yc, hh, i, j);
     sum_s0 += (autoc_data[i + jj] - fxx);
     sum_aa += (autoc_data[i + jj] - fxx) * back_model[i + jj];
     sum_bb += (autoc_data[i + jj] - fxx) * dfxx_bb;
  } /* EOF loop on i */
}  /* EOF loop on j */

  k = 0;
  grad_xx[k++] = -2. * sum_s0 / (double)npts;
  grad_xx[k++] = -2. * sum_aa / (double)npts;
  grad_xx[k++] = -2. * sum_bb / (double)npts;

for(m = 0; m < nstars; m++) {
/************** d/dxc d/dyc d/dhh  *****************/
  sum_xc = 0.;
  sum_yc = 0.;
  sum_hh = 0.;
/* To avoid division by zero: */
  if(hh[m] == 0.) hh[m] = 1.e-8;

  for (j = jmin; j < jmax; j++) {
    y = (double)j;
    dy = y - yc[m]; 
    for (i = imin; i < imax; i++) {
      x = (double)i;
      dx = x - xc[m]; 
      rr2 = SQUARE(dx) + SQUARE(dy);
      fxxm = hh[m] * exp(- rr2 * bb2);
      fxx = model1_value(s0, aa, bb2, xc, yc, hh, i, j);
/* d / d xc */
      dfxxm = 2. * dx * bb2 * fxxm; 
      sum_xc += (autoc_data[i + j * idim] - fxx) * dfxxm;
/* d / d yc */
      dfxxm = 2. * dy * bb2 * fxxm; 
      sum_yc += (autoc_data[i + j * idim] - fxx) * dfxxm;
/* d / d hh */
      dfxxm = fxxm / hh[m];
      sum_hh += (autoc_data[i + j * idim] - fxx) * dfxxm;
    }
  }
  grad_xx[k++] = -2. * sum_xc / (double)npts;
  grad_xx[k++] = -2. * sum_yc / (double)npts;
  grad_xx[k++] = -2. * sum_hh / (double)npts;
}   /* EOF loop on m */


#ifdef DEBUGG
 for(i = 0; i < nparams; i++) printf("gradx[%d]=%.3g ", i, grad_xx[i]);
 printf("\n");
#endif

return;
}
/**************************************************************
* Function to be minimized:
*
* value = (1/ n)  * sum [ autoc_data[i,j] - Sum_N gauss_m(i,j) - sky]^2 
*
* sky = s0 + aa * back_model[i,j] 
*
* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
**************************************************************/
static double model1_func(double *xx) 
{
double s0, aa, bb, bb2;
double fxx, sumsq, value; 
double hh[NSTARS_MAX], xc[NSTARS_MAX], yc[NSTARS_MAX];
int jj;
register int i, j;

param_from_xx(xx, &s0, &aa, &bb, xc, yc, hh, nstars);

sumsq = 0.;
bb2 = SQUARE(bb);

for (j = jmin; j < jmax; j++) {
  jj = j * idim;
  for (i = imin; i < imax; i++) {
    fxx = model1_value(s0, aa, bb2, xc, yc, hh, i, j);
    sumsq += SQUARE(autoc_data[i + jj] - fxx);
  }
}
value = sumsq / (double)npts;

#ifdef DEBUGG
printf(" model1_func: value=%.5g npts=%d\n", value, npts);
#endif
return(value);
}
/**********************************************************************
* Compute the theoretical profile value 
* compatible with the current set of parameters
*
* f(x,y) = hh1 * gauss(xc1, yc1, sig=1/bb) + hh2 * gauss(xc2, yc2, sig=1/bb)
*          + aa * model + s0
* fxx = hh[m] * exp( - rm2 * bb2) + aa * model + s0
**********************************************************************/
static double model1_value(double s0, double aa, double bb2, double *xc, 
                          double *yc, double *hh, int ix, int iy) 
{
double rm2, fxx, x, y;
register int m;

    fxx = 0.;
    x = double(ix);
    y = double(iy);
    for(m = 0; m < nstars; m++) {
      rm2 = SQUARE(x - xc[m]) + SQUARE(y - yc[m]);
      fxx += hh[m] * exp( - rm2 * bb2);
    } 
    fxx += s0 + aa * back_model[ix + iy * idim];
return(fxx);
}
/**********************************************************************
* Load the parameters from the xx array: 
*
* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
* For two stars:
* xx[0] = s0,  xx[1] = aa, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
* xx[6] = xc[1], xx[7] = yc[1], xx[8] = hh[1],
* nparams = 3*nstars + 3
***********************************************************************/
static int param_from_xx(double *xx, double *s0, double *aa, double *bb,
                         double *xc, double *yc, double *hh, int nstars)
{
register int k, m;

k = 0;
*s0 = xx[k++];
*aa = xx[k++];
*bb = xx[k++];

for(m = 0; m < nstars; m++) {
  xc[m] = xx[k++];
  yc[m] = xx[k++];
  hh[m] = xx[k++];
#ifdef DEBUGG
printf("Star #%d xc=%.3f yc=%.3f hh=%.3f\n", m, xc[m], yc[m], hh[m]);
#endif
  }

#ifdef DEBUGG
printf("s0=%.3f aa=%.3f bb=%.3f\n", *s0, *aa, *bb);
#endif

return(0);
}
/**************************************************************
* Check the validity of the gradient
* and compare f(x+dx)-f(x)/dx with grad_f(x)
*
* x1,x2,dx: work space of dimension nparams+1 
**************************************************************/
static int check_grad(double *x1, int nparams, double (*func)(double []), 
                      void (*dfunc)(double[], double[]))
{
double *x2, *dx;
int max_nparams;
register int i, j;
double eps=1.e-4, tolerance=1.e-2;
double f_x2, f_x1, error, relative_error;

max_nparams = 3*nstars + 3;
if( (x2 = (double *)malloc(max_nparams * sizeof(double))) == NULL
    || (dx = (double *)malloc(max_nparams * sizeof(double))) == NULL)
  {
   printf("check_grad/Fatal error allocating memory: dim=%d\n",
           max_nparams);
   exit(-1);
  }

printf(" check_grad/Start checking gradient \n");

/* Generate random vector (between 0 and 1) 
* not used here yet
for(i = 0; i < nparams; i++) x1[i] = (double)rand() / (double)RAND_MAX;
*/

f_x1 = (*func)(x1); 

/* Loop on all the components: */
for(i = 0; i < nparams; i++)
   {
   for(j = 0; j < max_nparams; j++) x2[j] = x1[j];
/* Small variation of component #i: */
   x2[i] = x1[i] + eps;
   f_x2 = (*func)(x2); 
   (*dfunc)(x1,dx);
   error = (f_x2 - f_x1)/eps - dx[i];
/* Relative error: (error with "abs", OK with "ABS") */
   relative_error = error / (ABS(dx[i]) + 1.e-12);
#ifdef DEBUG
   printf("x1[%d]=%.3f f_x1=%.3e f_x2=%.3e (f_x2 - f_x1)/eps=%e dx[i]=%e error=%e (relative=%e)\n",
            i, x1[i], f_x1, f_x2, (f_x2 - f_x1)/eps, dx[i], error, relative_error);
#endif
    if(relative_error > tolerance) {
      printf("check_grad/Error! \n");
      printf("component #i=%d:  dx=%.4e relative error =%.4e\n\n", i, 
              dx[i], relative_error);
      }
   }

printf("check_grad/gradient is OK. \n");

free(x2);
free(dx);
return(0);
}
/***************************************************************************
*
* OUTPUT:
* autoc_fname: name of the file containing the input data (autoc_data)
* n_stars: number of stars to be fitted
* xc[], yc[], hh[]: coordinates of the center (in pixels) and central brightness
*                   for each star
* fwhm: FWHM seeing (in pixels)
* factr: tolerance factor on the residuals (criterium to stop minimisation)
* pgtol: fit tolerance on the gradient (criterium to stop minimisation)
* is_OK: 1 if the user has pressed on OK
*        0 if the user has pressed on Cancel 
***************************************************************************/
static int interactive_input(char *autoc_fname, char *back_fname,
                             char *resid_fname, int *n_stars, double *xc, 
                             double *yc, double *fwhm, double *factr, 
                             double *pgtol, int *niter_max, int *is_OK)
{
int is_ok, nwidgets, small_size;
JLP_Dlg *JDlg0;
char label[NN][80], svalue[NN][80], val_type[NN];
int widget_type[NN], radio_group[NN], is_checked[NN];
register int i, m;

for(i = 0; i < NN; i++) {
  widget_type[i] = 0;
  radio_group[i] = -1;
  label[i][0] = '\0';
  svalue[i][0] = '\0';
  is_checked[i] = 0;
  val_type[i] = 'c';
  }

// Edit button:
i = 0;
widget_type[i] = 4;
strcpy(label[i], "Autoc. filename:");
val_type[i] = 'c';
strcpy(svalue[i], autoc_fname);

// Edit button:
i = 1;
widget_type[i] = 4;
strcpy(label[i], "Backgd filename:");
val_type[i] = 'c';
strcpy(svalue[i], back_fname);

// Edit button:
i = 2;
widget_type[i] = 4;
strcpy(label[i], "Resid filename:");
val_type[i] = 'c';
strcpy(svalue[i], resid_fname);


// Edit button:
i = 3;
widget_type[i] = 4;
strcpy(label[i], "Number of stars to be fitted:");
val_type[i] = 'd';
sprintf(svalue[i],"%d", *n_stars);

// Edit button:
i = 4;
widget_type[i] = 4;
strcpy(label[i], "FWHM seeing (pixels):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",5.0);

// ******************** Static label:
i = 5;
widget_type[i] = 1;
strcpy(label[i], "====== Approximative centers for the stars =======");

// Edit buttons:
// xc_1, yc_1
i = 6;
widget_type[i] = 4;
strcpy(label[i], "x-center (1):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",68.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (1):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",54.);

// Edit buttons:
// xc_2, yc_2
i = 8;
widget_type[i] = 4;
strcpy(label[i], "x-center (2):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",61.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (2):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",75.);

// ******************** Static label:
i = 10;
widget_type[i] = 1;
strcpy(label[i], "========== Parameters for the fit ==========");

// Edit button:
i = 11;
widget_type[i] = 4;
strcpy(label[i], "factr:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1e",*factr);

i++;
widget_type[i] = 4;
strcpy(label[i], "pgtol:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1e",*pgtol);

i++;
widget_type[i] = 4;
strcpy(label[i], "Max. number of iterations:");
val_type[i] = 'd';
sprintf(svalue[i],"%d",*niter_max);

nwidgets = i+1;

// Open new DialogBox (with big size):
small_size = 0;
JDlg0 = new JLP_Dlg("Parameters for fit_merate", small_size);

// Create the widgets:
JDlg0->CreateWidgets(label, widget_type, radio_group, val_type,
                     svalue, is_checked, nwidgets);

JDlg0->WaitForOK(svalue, is_checked, nwidgets, is_ok);

delete JDlg0;

for(i = 0; i < nwidgets; i++) {
  printf("Output from Dialog Box: svalue[%d]=%s, is_checked=%d\n",
         i,svalue[i], is_checked[i]);
  }

*is_OK = is_ok;

strcpy(autoc_fname, svalue[0]);
strcpy(back_fname, svalue[1]);
strcpy(resid_fname, svalue[2]);
sscanf(svalue[3],"%d",n_stars);
sscanf(svalue[4],"%lf",fwhm);
sscanf(svalue[6],"%lf",&xc[0]);
sscanf(svalue[7],"%lf",&yc[0]);
sscanf(svalue[8],"%lf",&xc[1]);
sscanf(svalue[9],"%lf",&yc[1]);
sscanf(svalue[11],"%le",factr);
sscanf(svalue[12],"%le",pgtol);
sscanf(svalue[13],"%d",niter_max);

printf("interactive_input/ nstars=%d\n", nstars); 
printf("autoc=%s, backgd=%s resid=%s\n", autoc_fname, back_fname, resid_fname); 
for(m = 0; m < nstars; m++)
   printf(" xc[%d]=%.2f yc[%d]=%.2f \n", m, xc[m], m, yc[m]);
printf("fwhm=%.2f\n", *fwhm);
printf("factr=%e pgtol=%e niter=%d is_OK=%d\n", *factr, *pgtol, *niter_max, 
        *is_OK);

return(0);
}
/***********************************************************************
* Setting the limits in the autoc_data for fitting the model 
*
***********************************************************************/
static int set_limits(double *xc, double *yc, int nstars, double fwhm)
{
int iwid;
register int m;

/* Take a small window around the central peak of each gaussian 
*/
 iwid = NINT(2. * fwhm);

 for(m = 0; m < nstars; m++) {
   imin[m] = MAXI(0, NINT(xc[m]) - iwid);
   imax[m] = MINI(nx, NINT(xc[m]) + iwid); 
   jmin[m] = MAXI(0, NINT(yc[m]) - iwid);
   jmax[m] = MINI(ny, NINT(yc[m]) + iwid); 
   }

return(0);
}
/**************************************************************************
*
*
**************************************************************************/
static int compute_residuals(float *autoc_data, float *model, int nx, int ny, 
                             int idim, double s0, double aa, double bb, 
                             double *xc, double *yc, double *hh)
{
register int i, j;
int jj;
double fxx, bb2;

bb2 = bb * bb;

for(j = 0; j < ny; j++) {
  jj = j * idim; 
  for(i = 0; i < nx; i++) {
    fxx = model1_value(s0, aa, bb2, xc, yc, hh, i, j);
    model[i + jj] = fxx;
    autoc_data[i + jj] -= fxx;
  }
}

return (0);
}
/**************************************************************************
*
*
**************************************************************************/
static int symmetrize_residuals(float *resid, int nx, int ny, int idim)
{
float ww;
int nx2, ny2;
register int i, j;

nx2 = nx / 2;
ny2 = ny / 2;

/* First compute values of left half: */
for(j = 0; j < ny; j++) {
 for(i = 0; i < nx2; i++) {
  ww = resid[i + j * idim];
  resid[i + j * idim] = (ww + resid[(nx - i - 1) + (ny - j - 1) * idim])/2.;
/* Symmetrize to right half: */
  resid[(nx - i - 1) + (ny - j - 1) * idim] = resid[i + j * idim];
 }
}

/* Central column: */
i = nx2;
for(j = 0; j < ny2; j++) {
  ww = resid[i + j * idim];
  resid[i + j * idim] = (ww + resid[(nx - i - 1) + (ny - j - 1) * idim])/2.;
  resid[(nx - i - 1) + (ny - j - 1) * idim] = resid[i + j * idim];
  }

return(0);
}
