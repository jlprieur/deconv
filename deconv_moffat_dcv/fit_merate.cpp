/****************************************************************** 
* fit_merate
* Program to obtain astrometry of close binaries
* from autocorrelations
*
* Subtract a model of the central peak (back_model)
* and fit a Gaussian to the secondary peaks (within a circle)
*         plus a 2nd order polynomial on a ring outside the circle 
*
* f(x,y) = hh1 * gauss(xc1, yc1, sig1)_in_circle1 
*          + hh2 * gauss(xc2, yc2, sig2)_in_circle2
*          + (a1 * back_model + a0)_global 
*          + (s1[0] + s1[1] * x + s1[2] * y + s1[3] * x^2
*             + s1[4] * xy + s1[5] * y^2)_ring1
*          + (s2[0] + s2[1] * x + s2[2] * y + s2[3] * x^2
*             + s2[4] * xy + s2[5] * y^2)_ring2
*
* JLP
* Version 30/01/2007
*******************************************************************/ 
#include "jlp_ftoc.h"
#include "../splot/lib/jlp_dialog.h"
#include "../splot/lib/jlp_dlg_x11.h"


#define NN 60

#define DEBUG
/*
#define CHECK_GRAD 
#define DEBUGG
*/
#define NSTARS 2
#define NCOEFF 6

/*
* i_min, i_max, j_min, j_max: coordinates (in pixels) of the area to be used
*                             in the input image
*/
static int nstars, nparams, imin, imax, jmin, jmax, idim, npts;
static float *autoc_data; 
static double a1, a0, sky[NSTARS][NCOEFF]; 
static int xcent[NSTARS], ycent[NSTARS], radmin, radmax; 

/******************* Prototypes: ****************************/

/* Declaring linkage specification to have "correct names"
* that can be linked with C programs */

#ifdef __cplusplus
extern "C" {
#endif

/* In "../math/lbfgs_bcm/dcv_lbfgs.c" */
int JLP_LBFGS(int *n, double *x, double *lbound, double *ubound,
              int *nbound, double *f, double *ftol, double *pgtol,
              int *niter_max, double (*func)(double *),
              void (*dfunc)(double *, double *));

#ifdef __cplusplus
}
#endif


/* Defined here: */
static int compute_a1(float *autoc_data, float *back_model, 
                      int imin, int imax, int jmin, int jmax, int idim,
                      double *a1, double *a0);
static int compute_sky(float *autoc_data, int *xcent, int *ycent, int radmin,
                       int radmax, int nx, int ny, int idim,
                       double sky[][NCOEFF]);
static int interactive_input(char *autoc_fname, char *back_fname,
                             char *resid_fname, int *n_stars, double *xc, 
                             double *yc, int *radmin, double *factr, 
                             double *pgtol, int *niter_max, int *is_OK);
static int symmetrize_residuals(float *resid, int nx, int ny, int idim);
static double model1_value(double sky[][NCOEFF], double bb2, double *xc, 
                           double *yc, double *hh, int ix, int iy, int m);
static int fit_model1(double *xx, double *xc, double *yc, double factr, 
                      double pgtol, int niter_max);
static double model1_func(double *xx);
static void model1_dfunc(double *xx, double *dx);
static int param_from_xx(double *xx, double sky[][NCOEFF], double *bb, 
                         double *xc, double *yc, double *hh, int nstars);
static int check_grad(double *x1, int nparams, double (*func)(double []), 
                      void (*dfunc)(double[], double[]));
static int set_limits(double *xc, double *yc, int *imin, int *imax, int *jmin, 
                      int *jmax, int nstars, int nx, int ny, double fwhm);
static int compute_residuals(float *autoc_data, float *model1, int nx, int ny, 
                             int idim, double sky[][NCOEFF], double bb, 
                             double *xc, double *yc, double *hh);

int main(int argc, char *argv[])
{
int status, interactive, is_OK, niter_max; 
INT_PNTR pntr;
INT4 nx, ny, nx1, ny1;
float *model1, *back_model;
double *xx, factr, pgtol; 
double xc[NSTARS], yc[NSTARS], hh[NSTARS]; 
double fwhm, bb; 
register int i, j, k, m;
char autoc_fname[60], back_fname[60], resid_fname[60];
char comments[80], param_file[60];
int ii, jj;

printf(" Program to fit a model to compute astrometry from autocorrelations\n");
printf(" JLP version 30/01/2007\n");

/* Reduce the number of arguments when "runs" is used and  argc=7 */
if(argc == 7)
 {
 for(i = 6; i > 0; i--)
  {
   if(*argv[i] == ' ' || *argv[i] == '\0')argc--;
   else break;
  }
 }

/* Default values: */
interactive = 1;
nstars = 2;

/*     factr is a DOUBLE PRECISION variable that must be set by the user.
c       It is a tolerance in the termination test for the algorithm.
c       The iteration will stop when
c
c        (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
c
c       where epsmch is the machine precision which is automatically
c       generated by the code. Typical values for factr on a computer
c       with 15 digits of accuracy in double precision are:
c       factr=1.e+12 for low accuracy;
c             1.e+7  for moderate accuracy;
c             1.e+1  for extremely high accuracy.
c       The user can suppress this termination test by setting factr=0.
c
c     pgtol is a double precision variable.
c       On entry pgtol >= 0 is specified by the user.  The iteration
c         will stop when
c
c                 max{|proj dx_i | i = 1, ..., n} <= pgtol
c
c         where proj dx_i is the ith component of the projected gradient.
c       The user can suppress this termination test by setting pgtol=0.
*/
factr = 1.e+1;
pgtol = 1.e-9;
niter_max = 2000;
autoc_fname[0] = '\0';
strcpy(back_fname, "unres_d_patched");
strcpy(resid_fname, "merate_resid");

if(argc > 1)
{
sscanf(argv[1],"%s", autoc_fname);
if(argc > 2) {
  sscanf(argv[2],"%s", param_file);
  interactive = 0;
  }
}
else
{
printf(" Usage: fit_merate autoc_fname [param_file] \n");
/*
exit(-1);
*/
}

/* Display popup window with default values: */
if(interactive) {
  interactive_input(autoc_fname, back_fname, resid_fname, &nstars, xc, yc, 
                    &radmin, &factr, &pgtol, &niter_max, &is_OK);
  fwhm = (float)radmin / 2.;
  bb = 2. / fwhm;
#ifdef DEBUG
printf(" fwhm=%f bb=%f\n", fwhm, bb);
#endif
  if(!is_OK) exit(-1);
}

printf("OK: autoc=%s nstars=%d factr=%e pgtol=%e\n", 
        autoc_fname, nstars, factr, pgtol);

if(nstars < 0 || nstars > NSTARS) {
 fprintf(stderr, "fit_merate/Fatal error invalid value for nstars (=%d !) \n",
         nstars);
 exit(-1);
 }

/* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* s0 + s1 * x + s2 * y + s3 * x2 + s4 * xy + s5 * y2
* + s6 * x3 + s7 * x2 y + s8 * x y2 + s9 * y3
* xx[0] = sky[0][0],  xx[1] = sky[0][1], ... xx[9] = sky[0][9] 
* xx[10] = xc[0], xx[11] = yc[0], xx[12] = hh[0], xx[13] = sig[0]
* nparams = 3*nstars + 3
*/

/* a0, a1, bb, and (xc, yc, hh)*nstars */
 nparams = 3*nstars + 3;

/* Allocate memory for xx: */
if((xx = (double *)malloc((3*nstars + 3) * sizeof(double))) == NULL) {
 fprintf(stderr, "fit_merate/Fatal error allocating memory space for xx\n");
  exit(-1);
 }

JLP_INQUIFMT();

/* Read input images: autoc_data and back_model 
*/
status = JLP_VM_READIMAG1(&pntr, &nx, &ny, autoc_fname, comments);
if(status) exit(-1);
autoc_data = (float *) pntr;
idim = nx;

status = JLP_VM_READIMAG1(&pntr, &nx1, &ny1, back_fname, comments);
if(status) exit(-1);
back_model = (float *) pntr;
if(nx1 != nx || ny1 != nx) {
  printf("fit_merate/fatal error: inconsistent sizes: nx=%d ny=%d nx1=%d ny1=%d\n",
          nx, ny, nx1, ny1);
  exit(-1);
  }

/* First guess: 
*/

k = 0;

/* Central brightness hh is taken equal to the autoc_data value 
* at the location (xc, yc): 
*/
for(m = 0; m < nstars; m++) {
  i = NINT(xc[m]) + NINT(yc[m]) * idim ;
  hh[m] = autoc_data[i] - a1 * back_model[i] - a0; 
  }

/*
* For one star:
* xx[0] = a0,  xx[1] = a1, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
*/
if(interactive) {
  k = 0;
  xx[k++] = a0;
  xx[k++] = a1;
  xx[k++] = bb;
  for(m = 0; m < nstars; m++) {
    xx[k++] = xc[m]; 
    xx[k++] = yc[m]; 
    xx[k++] = hh[m];
    }
} else {
printf("Parameter file: not yet implemented \n");
exit(-1);
}

#ifdef DEBUG
printf("k=%d nparams=%d\n", k, nparams);
for(i = 0; i < nparams; i++) 
   printf("Initialisation/xx[%d] = %f\n", i, xx[i]);
#endif

 set_limits(xc, yc, &imin, &imax, &jmin, &jmax, nstars, nx, ny, fwhm);
 npts = 0; 
 for(j = jmin; j < jmax; j++)
   for(i = imin; i < imax; i++) npts++;

/* Possibility of checking that the gradient is OK: */
#ifdef CHECK_GRAD 
status = check_grad(xx, nparams, model1_func, model1_dfunc);
if(status != 12345) return(0);
#endif

compute_a1(autoc_data, back_model, imin, imax, jmin, jmax, idim,
           &a1, &a0);


for(j = 0; j < ny; j++) {
  jj = j * nx;
  for(i = 0; i < nx; i++) {
   ii = i + jj;
   autoc_data[ii] -= (a1 * back_model[ii] + a0);
  }
}

/* Call compute_sky after subtraction of back_model: */
radmax = NINT((float)radmin * 2.);
compute_sky(autoc_data, xcent, ycent, radmin, radmax, nx, ny, idim, sky);

#ifdef TTT
status = fit_model1(xx, xc, yc, factr, pgtol, niter_max);

printf(" Solution with factr=%e and pgtol=%e is: (with npts=%d)\n", 
         factr, pgtol, npts);

sprintf(comments,"Fitted model to %s", autoc_fname);
strcpy(resid_fname, "merate_model.fits");
JLP_WRITEIMAG(model1, &nx, &ny, &nx, resid_fname, comments);

/* Compute values of parameters from solution vector xx: */
param_from_xx(xx, &a0, &a1, &bb, xc, yc, hh, nstars);
#endif

for(m = 0; m < nstars; m++) 
    printf(" Star#%d xc=%f yc=%f hh=%f\n", m, xc[m], yc[m], hh[m]);

fwhm = 2. / bb;
printf(" a0=%f a1=%f bb=%f (fwhm=%f)\n", a0, a1, bb, fwhm);

model1 = (float *)malloc(nx * ny * sizeof(float));

compute_residuals(autoc_data, model1, nx, ny, nx, a0, a1, bb, xc, yc, hh);

sprintf(comments,"Residuals from %s", autoc_fname);
JLP_WRITEIMAG(autoc_data, &nx, &ny, &nx, resid_fname, comments);

symmetrize_residuals(autoc_data, nx, ny, nx);

sprintf(comments,"Symmetric version of %s", resid_fname);
strcpy(resid_fname, "merate_resi_sym.fits");
JLP_WRITEIMAG(autoc_data, &nx, &ny, &nx, resid_fname, comments);

free(xx);
free(model1);
return(0);
}
/***********************************************************************
* LBFGS version with bounded constraints on the parameters
*
* INPUT:
* autoc_data: array to be fitted
* nstars: number of stars to be fitted
* xx: first guess of the parameters for the model 
*
* OUTPUT
* xx: parameters found for the model 
************************************************************************/
static int fit_model1(double *xx, double *xc, double *yc, double factr, 
                       double pgtol, int niter_max)
{
double fret, rms_resi;
double *lbound, *ubound, ipix;
int nn, *nbound;
register int m, k;

/* Allocate enough memory to fit all parameters: */
 nbound = (int *)malloc((3*nstars + 8) * sizeof(int));
 lbound = (double *)malloc((3*nstars + 8) * sizeof(double));
 ubound = (double *)malloc((3*nstars + 8) * sizeof(double));
/*
*  To provide nbound which defines the bounds on the variables:
*  nbound   specifies the number of bounds (0, 1, 2 or 3),
*  lbound   specifies the lower bounds,
*  ubound   specifies the upper bounds.
*
*    nbound(i)=0 if x(i) is unbounded,
*              1 if x(i) has only a lower bound,
*              2 if x(i) has both lower and upper bounds,
*              3 if x(i) has only an upper bound.
*/
/* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = a0,  xx[1] = a1, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
*/
k = 0;

/* No bounds on a0, a1: */
nbound[k] = 0; lbound[k] = ubound[k] = 0.;
k++;
nbound[k] = 0; lbound[k] = ubound[k] = 0.;
k++;
/* Lower bound only (bb must be positive) */
nbound[k] = 1; lbound[k] = 0.; ubound[k] = 0.;
k++;

/* ipix: accuracy on the guessed center in pixels */
ipix = 5.;
for(m = 0; m < nstars; m++) {
/* xc +/- ipix */
  nbound[k] = 2; 
  lbound[k] = xc[m] - ipix; 
  ubound[k] = xc[m] + ipix;
  k++;
/* yc +/- ipix */
  nbound[k] = 2;
  lbound[k] = yc[m] - ipix; 
  ubound[k] = yc[m] + ipix;
/* Lower bound only (hh must be positive) */
  k++;
  nbound[k] = 1; lbound[k] = 0.; ubound[k] = 0.;
  k++;
 } /* EOF loop on m */
printf("Number of parameters: k=%d (nparams=%d)\n", k, nparams);
for (k = 0; k < nparams; k++) {
 printf("nbounds[%d]=%d low=%f up=%f\n", k, nbound[k], lbound[k], ubound[k]);
 }

nn = nparams;
 JLP_LBFGS(&nn, xx, lbound, ubound, nbound, &fret, &factr, &pgtol, 
           &niter_max, model1_func, model1_dfunc);

 rms_resi = sqrt(fret);
 printf(" Mean value of the residuals for the minimum: %.5g\n", rms_resi);

 free(nbound);
 free(lbound);
 free(ubound);
return(0);
}
/**************************************************************
* Gradient of function to be minimized
*
* gradient of (1/ n)  * sum [ autoc_data[i,j] - merate(i,j) ]^2 
*
* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = a0,  xx[1] = a1, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
**************************************************************/
static void model1_dfunc(double *xx, double *grad_xx)
{
double hh[NSTARS], xc[NSTARS], yc[NSTARS]; 
double a0, a1, bb, bb2;
register int i, j, k, m;
double sum_a0, sum_a1, sum_bb, sum_xc, sum_yc, sum_hh;
double x, y, dx, dy, rr2, fxxm, dfxxm, dfxx_bb, fxx; 
int jj;

param_from_xx(xx, &a0, &a1, &bb, xc, yc, hh, nstars);
bb2 = SQUARE(bb);

/* Initialization (useful if return in case of error) */
for(k = 0; k < nparams; k++) {
 grad_xx[k] = 0.;
 }

/******* d/da0 d/da1 d/dbb *****************/
  sum_a0 = 0.;
  sum_a1 = 0.;
  sum_bb = 0.;
for (j = jmin; j < jmax; j++) {
  y = (double)j;
  jj = j * idim;
  for (i = imin; i < imax; i++) {
    x = (double)i;
    dfxx_bb = 0.;
/*************** Loop on all stars *****************/
    for(m = 0; m < nstars; m++) {
      dy = y - yc[m]; 
      dx = x - xc[m]; 
      rr2 = SQUARE(dx) + SQUARE(dy);
      fxxm = hh[m] * exp( - rr2 * bb2);
/* d / d bb */
      dfxx_bb += fxxm * (-2. * bb * rr2); 
     }  /* EOF loop on m=0, nstars */
     fxx = model1_value(a0, a1, sky, bb2, xc, yc, hh, i, j, m);
     sum_a0 += (autoc_data[i + jj] - fxx);
     sum_bb += (autoc_data[i + jj] - fxx) * dfxx_bb;
  } /* EOF loop on i */
}  /* EOF loop on j */

  k = 0;
  grad_xx[k++] = -2. * sum_a0 / (double)npts;
  grad_xx[k++] = -2. * sum_a1 / (double)npts;
  grad_xx[k++] = -2. * sum_bb / (double)npts;

for(m = 0; m < nstars; m++) {
/************** d/dxc d/dyc d/dhh  *****************/
  sum_xc = 0.;
  sum_yc = 0.;
  sum_hh = 0.;
/* To avoid division by zero: */
  if(hh[m] == 0.) hh[m] = 1.e-8;

  for (j = jmin; j < jmax; j++) {
    y = (double)j;
    dy = y - yc[m]; 
    for (i = imin; i < imax; i++) {
      x = (double)i;
      dx = x - xc[m]; 
      rr2 = SQUARE(dx) + SQUARE(dy);
      fxxm = hh[m] * exp(- rr2 * bb2);
      fxx = model1_value(a0, a1, sky, bb2, xc, yc, hh, i, j, m);
/* d / d xc */
      dfxxm = 2. * dx * bb2 * fxxm; 
      sum_xc += (autoc_data[i + j * idim] - fxx) * dfxxm;
/* d / d yc */
      dfxxm = 2. * dy * bb2 * fxxm; 
      sum_yc += (autoc_data[i + j * idim] - fxx) * dfxxm;
/* d / d hh */
      dfxxm = fxxm / hh[m];
      sum_hh += (autoc_data[i + j * idim] - fxx) * dfxxm;
    }
  }
  grad_xx[k++] = -2. * sum_xc / (double)npts;
  grad_xx[k++] = -2. * sum_yc / (double)npts;
  grad_xx[k++] = -2. * sum_hh / (double)npts;
}   /* EOF loop on m */


#ifdef DEBUGG
 for(i = 0; i < nparams; i++) printf("gradx[%d]=%.3g ", i, grad_xx[i]);
 printf("\n");
#endif

return;
}
/**************************************************************
* Function to be minimized:
*
* value = (1/ n)  * sum [ autoc_data[i,j] - Sum_N gauss_m(i,j) - sky]^2 
*
* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = a0,  xx[1] = a1, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
**************************************************************/
static double model1_func(double *xx) 
{
double a0, a1, bb, bb2;
double fxx, sumsq, value; 
double hh[NSTARS], xc[NSTARS], yc[NSTARS];
int jj, m;
register int i, j;

param_from_xx(xx, &a0, &a1, &bb, xc, yc, hh, nstars);

sumsq = 0.;
bb2 = SQUARE(bb);

m = 0;
for (j = jmin; j < jmax; j++) {
  jj = j * idim;
  for (i = imin; i < imax; i++) {
    fxx = model1_value(a0, a1, sky, bb2, xc, yc, hh, i, j, m);
    sumsq += SQUARE(autoc_data[i + jj] - fxx);
  }
}
value = sumsq / (double)npts;

#ifdef DEBUGG
printf(" model1_func: value=%.5g npts=%d\n", value, npts);
#endif
return(value);
}
/**********************************************************************
* Compute the theoretical profile value 
* compatible with the current set of parameters
*
* f(x,y) = hh1 * gauss(xc1, yc1, sig=1/bb) + hh2 * gauss(xc2, yc2, sig=1/bb)
*          + a1 * model + a0 + sky_val
* fxx = hh[m] * exp( - rm2 * bb2) + a1 * model + a0
**********************************************************************/
static double model1_value(double a0, double a1, double sky[][NCOEFF],
                           double bb2, double *xc, double *yc, double *hh, 
                           int ix, int iy, int m) 
{
double rm2, fxx, x, y, sky_val;

    x = double(ix);
    y = double(iy);
    sky_val = sky[m][0] + sky[m][1] * x + sky[m][2] * y + sky[m][3] * x * x
          + sky[m][4] * x * y + sky[m][5] * y * y;
    rm2 = SQUARE(x - xc[m]) + SQUARE(y - yc[m]);
    fxx = hh[m] * exp( - rm2 * bb2) + sky_val;
return(fxx);
}
/**********************************************************************
* Load the parameters from the xx array: 
*
* xx array with the parameters (from 0 to 3*nstars + 2):
* For one star:
* xx[0] = a0,  xx[1] = a1, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
* For two stars:
* xx[0] = a0,  xx[1] = a1, xx[2] = bb
* xx[3] = xc[0], xx[4] = yc[0], xx[5] = hh[0],
* xx[6] = xc[1], xx[7] = yc[1], xx[8] = hh[1],
* nparams = 3*nstars + 3
***********************************************************************/
static int param_from_xx(double *xx, double *a0, double *a1, double *bb,
                         double *xc, double *yc, double *hh, int nstars)
{
register int k, m;

k = 0;
*a0 = xx[k++];
*a1 = xx[k++];
*bb = xx[k++];

for(m = 0; m < nstars; m++) {
  xc[m] = xx[k++];
  yc[m] = xx[k++];
  hh[m] = xx[k++];
#ifdef DEBUGG
printf("Star #%d xc=%.3f yc=%.3f hh=%.3f\n", m, xc[m], yc[m], hh[m]);
#endif
  }

#ifdef DEBUGG
printf("a0=%.3f a1=%.3f bb=%.3f\n", *a0, *a1, *bb);
#endif

return(0);
}
/**************************************************************
* Check the validity of the gradient
* and compare f(x+dx)-f(x)/dx with grad_f(x)
*
* x1,x2,dx: work space of dimension nparams+1 
**************************************************************/
static int check_grad(double *x1, int nparams, double (*func)(double []), 
                      void (*dfunc)(double[], double[]))
{
double *x2, *dx;
int max_nparams;
register int i, j;
double eps=1.e-4, tolerance=1.e-2;
double f_x2, f_x1, error, relative_error;

max_nparams = 3*nstars + 3;
if( (x2 = (double *)malloc(max_nparams * sizeof(double))) == NULL
    || (dx = (double *)malloc(max_nparams * sizeof(double))) == NULL)
  {
   printf("check_grad/Fatal error allocating memory: dim=%d\n",
           max_nparams);
   exit(-1);
  }

printf(" check_grad/Start checking gradient \n");

/* Generate random vector (between 0 and 1) 
* not used here yet
for(i = 0; i < nparams; i++) x1[i] = (double)rand() / (double)RAND_MAX;
*/

f_x1 = (*func)(x1); 

/* Loop on all the components: */
for(i = 0; i < nparams; i++)
   {
   for(j = 0; j < max_nparams; j++) x2[j] = x1[j];
/* Small variation of component #i: */
   x2[i] = x1[i] + eps;
   f_x2 = (*func)(x2); 
   (*dfunc)(x1,dx);
   error = (f_x2 - f_x1)/eps - dx[i];
/* Relative error: (error with "abs", OK with "ABS") */
   relative_error = error / (ABS(dx[i]) + 1.e-12);
#ifdef DEBUG
   printf("x1[%d]=%.3f f_x1=%.3e f_x2=%.3e (f_x2 - f_x1)/eps=%e dx[i]=%e error=%e (relative=%e)\n",
            i, x1[i], f_x1, f_x2, (f_x2 - f_x1)/eps, dx[i], error, relative_error);
#endif
    if(relative_error > tolerance) {
      printf("check_grad/Error! \n");
      printf("component #i=%d:  dx=%.4e relative error =%.4e\n\n", i, 
              dx[i], relative_error);
      }
   }

printf("check_grad/gradient is OK. \n");

free(x2);
free(dx);
return(0);
}
/***************************************************************************
*
* OUTPUT:
* autoc_fname: name of the file containing the input data (autoc_data)
* n_stars: number of stars to be fitted
* xc[], yc[], hh[]: coordinates of the center (in pixels) and central brightness
*                   for each star
* radmin: radius of the disk to be used for fitting the Gaussian 
* factr: tolerance factor on the residuals (criterium to stop minimisation)
* pgtol: fit tolerance on the gradient (criterium to stop minimisation)
* is_OK: 1 if the user has pressed on OK
*        0 if the user has pressed on Cancel 
***************************************************************************/
static int interactive_input(char *autoc_fname, char *back_fname,
                             char *resid_fname, int *n_stars, double *xc, 
                             double *yc, int *radmin, double *factr, 
                             double *pgtol, int *niter_max, int *is_OK)
{
int is_ok, nwidgets, small_size;
JLP_Dlg *JDlg0;
char label[NN][80], svalue[NN][80], val_type[NN];
int widget_type[NN], radio_group[NN], is_checked[NN];
register int i, m;

for(i = 0; i < NN; i++) {
  widget_type[i] = 0;
  radio_group[i] = -1;
  label[i][0] = '\0';
  svalue[i][0] = '\0';
  is_checked[i] = 0;
  val_type[i] = 'c';
  }

// Edit button:
i = 0;
widget_type[i] = 4;
strcpy(label[i], "Autoc. filename:");
val_type[i] = 'c';
strcpy(svalue[i], autoc_fname);

// Edit button:
i = 1;
widget_type[i] = 4;
strcpy(label[i], "Backgd filename:");
val_type[i] = 'c';
strcpy(svalue[i], back_fname);

// Edit button:
i = 2;
widget_type[i] = 4;
strcpy(label[i], "Resid filename:");
val_type[i] = 'c';
strcpy(svalue[i], resid_fname);


// Edit button:
i = 3;
widget_type[i] = 4;
strcpy(label[i], "Number of stars to be fitted:");
val_type[i] = 'd';
sprintf(svalue[i],"%d", *n_stars);

// Edit button:
i = 4;
widget_type[i] = 4;
strcpy(label[i], "Radius for the Gaussian fit (pixels):");
val_type[i] = 'd';
sprintf(svalue[i],"%d",5);

// ******************** Static label:
i = 5;
widget_type[i] = 1;
strcpy(label[i], "====== Approximative centers for the stars =======");

// Edit buttons:
// xc_1, yc_1
i = 6;
widget_type[i] = 4;
strcpy(label[i], "x-center (1):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",68.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (1):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",54.);

// Edit buttons:
// xc_2, yc_2
i = 8;
widget_type[i] = 4;
strcpy(label[i], "x-center (2):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",61.);

i++;
widget_type[i] = 4;
strcpy(label[i], "y-center (2):");
val_type[i] = 'f';
sprintf(svalue[i],"%.1f",75.);

// ******************** Static label:
i = 10;
widget_type[i] = 1;
strcpy(label[i], "========== Parameters for the fit ==========");

// Edit button:
i = 11;
widget_type[i] = 4;
strcpy(label[i], "factr:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1e",*factr);

i++;
widget_type[i] = 4;
strcpy(label[i], "pgtol:");
val_type[i] = 'f';
sprintf(svalue[i],"%.1e",*pgtol);

i++;
widget_type[i] = 4;
strcpy(label[i], "Max. number of iterations:");
val_type[i] = 'd';
sprintf(svalue[i],"%d",*niter_max);

nwidgets = i+1;

// Open new DialogBox (with big size):
small_size = 0;
JDlg0 = new JLP_Dlg("Parameters for fit_merate", small_size);

// Create the widgets:
JDlg0->CreateWidgets(label, widget_type, radio_group, val_type,
                     svalue, is_checked, nwidgets);

JDlg0->WaitForOK(svalue, is_checked, nwidgets, is_ok);

delete JDlg0;

/* DEBUG:
for(i = 0; i < nwidgets; i++) {
  printf("Output from Dialog Box: svalue[%d]=%s, is_checked=%d\n",
         i,svalue[i], is_checked[i]);
  }
*/

*is_OK = is_ok;

strcpy(autoc_fname, svalue[0]);
strcpy(back_fname, svalue[1]);
strcpy(resid_fname, svalue[2]);
sscanf(svalue[3],"%d",n_stars);
sscanf(svalue[4],"%d",radmin);
sscanf(svalue[6],"%lf",&xc[0]);
sscanf(svalue[7],"%lf",&yc[0]);
sscanf(svalue[8],"%lf",&xc[1]);
sscanf(svalue[9],"%lf",&yc[1]);
sscanf(svalue[11],"%le",factr);
sscanf(svalue[12],"%le",pgtol);
sscanf(svalue[13],"%d",niter_max);

printf("interactive_input/ nstars=%d\n", nstars); 
printf("autoc=%s, backgd=%s resid=%s\n", autoc_fname, back_fname, resid_fname); 
for(m = 0; m < nstars; m++)
   printf(" xc[%d]=%.2f yc[%d]=%.2f \n", m, xc[m], m, yc[m]);
printf("radmin=%d\n", *radmin);
printf("factr=%e pgtol=%e niter=%d is_OK=%d\n", *factr, *pgtol, *niter_max, 
        *is_OK);

return(0);
}
/***********************************************************************
* Setting the limits in the autoc_data for fitting the model 
*
***********************************************************************/
static int set_limits(double *xc, double *yc, int *imin, int *imax, int *jmin, 
                      int *jmax, int nstars, int nx, int ny, double fwhm)
{
int iwid, ix, iy, ixmin, ixmax, iymin, iymax;
register int m;

/* Take a window that takes the two stars into account with a width of 4 fwhm: 
*/
 iwid = NINT(1004. * fwhm);

 ixmin = NINT(xc[0]);
 ixmax = ixmin; 
 iymin = NINT(yc[0]);
 iymax = iymin; 

 for(m = 0; m < nstars; m++) {
   ix = NINT(xc[0]);
   ixmin = MINI(ix, ixmin);
   ixmax = MAXI(ix, ixmax);
   iy = NINT(yc[0]);
   iymin = MINI(iy, iymin);
   iymax = MAXI(iy, iymax);
   }

 *imin = MAXI(0, ixmin - iwid);
 *imax = MINI(nx, ixmax + iwid); 
 *jmin = MAXI(0, iymin - iwid);
 *jmax = MINI(ny, iymax + iwid); 

printf("Limits: imin=%d imax=%d jmin=%d jmax=%d\n", *imin, *imax, *jmin, *jmax);

return(0);
}
/**************************************************************************
*
*
**************************************************************************/
static int compute_residuals(float *autoc_data, float *model1, int nx, int ny, 
                             int idim, double a0, double a1, double bb, 
                             double *xc, double *yc, double *hh)
{
register int i, j;
int jj, m;
double fxx, bb2;

bb2 = bb * bb;

m = 0;
for(j = 0; j < ny; j++) {
  jj = j * idim; 
  for(i = 0; i < nx; i++) {
    fxx = model1_value(a0, a1, sky, bb2, xc, yc, hh, i, j, m);
    model1[i + jj] = fxx;
    autoc_data[i + jj] -= fxx;
  }
}

return (0);
}
/**************************************************************************
*
*
**************************************************************************/
static int symmetrize_residuals(float *resid, int nx, int ny, int idim)
{
float ww;
int nx2, ny2;
register int i, j;

nx2 = nx / 2;
ny2 = ny / 2;

/* First compute values of left half: */
for(j = 0; j < ny; j++) {
 for(i = 0; i < nx2; i++) {
  ww = resid[i + j * idim];
  resid[i + j * idim] = (ww + resid[(nx - i - 1) + (ny - j - 1) * idim])/2.;
/* Symmetrize to right half: */
  resid[(nx - i - 1) + (ny - j - 1) * idim] = resid[i + j * idim];
 }
}

/* Central column: */
i = nx2;
for(j = 0; j < ny2; j++) {
  ww = resid[i + j * idim];
  resid[i + j * idim] = (ww + resid[(nx - i - 1) + (ny - j - 1) * idim])/2.;
  resid[(nx - i - 1) + (ny - j - 1) * idim] = resid[i + j * idim];
  }

return(0);
}
/**************************************************************************
* Compute the coefficients to subtract the background model on all the frame
*
* Linear regression:
*
* Minimum of Sum ( z - a1 f - a0)^2
* is reached when gradient is nul, i.e., when:
* sum_fz = a1 sum_ff - a0 sum_f
* sum_z  = a1 sum_f - a0 sum_1 
**************************************************************************/
static int compute_a1(float *autoc_data, float *back_model, 
                      int imin, int imax, int jmin, int jmax, int idim,
                      double *a1, double *a0)
{
double sum_1, sum_f, sum_z, sum_fz, sum_ff;
double det;
int jj;
register int i, j;

sum_1 = 0.;
sum_f = 0.;
sum_z = 0.;
sum_fz = 0.;
sum_ff = 0.;
for(j = jmin; j < jmax; j++) {
  jj = j * idim;
  for(i = imin; i < imax; i++) {
   sum_1 += 1.;
   sum_f += back_model[i + jj];
   sum_z += autoc_data[i + jj];
   sum_fz += back_model[i + jj] * autoc_data[i + jj];
   sum_ff += SQUARE(back_model[i + jj]);
  }
 }

det = sum_ff * sum_1 - sum_f * sum_f;
*a1 = (sum_1 * sum_fz  - sum_f * sum_z) / det; 
*a0 = (sum_ff * sum_z  - sum_f * sum_fz) / det; 

printf("compute_a1/ a1=%f a0=%f\n", *a1, *a0);

return(0);
}
/**************************************************************************
* Compute the coefficients to subtract the background model on all the frame
*
**************************************************************************/
static int compute_sky(float *autoc_data, int *xcent, int *ycent, int radmin,
                       int radmax, int nx, int ny, int idim,
                       double sky[][NCOEFF])
{
int rad2, dy2, m, ix1, ix2, iy1, iy2;
int rad2min, rad2max, npts, jj;
float z[10000];
register int i, j, k;

m = 0;

ix1 = MAXI(0, xcent[m] - radmax); 
ix2 = MINI(nx, xcent[m] + radmax + 1); 
iy1 = MAXI(0, ycent[m] - radmax); 
iy2 = MINI(ny, ycent[m] + radmax + 1); 

rad2max = SQUARE(radmax);
rad2min = SQUARE(radmin);

k = 0;
for(j = iy1; j < iy2; j++) {
  dy2 = SQUARE(j - ycent[m]);
  jj = j * idim;
  for(i = ix1; i < ix2; i++) {
    rad2 = SQUARE(i - xcent[m]) + dy2; 
    if(rad2 > rad2min && rad2 <= rad2max) { 
      z[k++] = autoc_data[i + jj];
      }
  }
}
npts = k;
printf("compute_sky/ npts=%d\n", npts);

return(0);
}
